<?xml version="1.0"?>
<doc>
    <assembly>
        <name>dotNetRDF.Core</name>
    </assembly>
    <members>
        <member name="T:VDS.RDF.Attributes.ConfigurationObjectFactoryAttribute">
            <summary>
            An attribute used to declare available configuration object factories
            </summary>
            <remarks>
            When the Configuration API provided by the 
            </remarks>
        </member>
        <member name="P:VDS.RDF.Attributes.ConfigurationObjectFactoryAttribute.FactoryType">
            <summary>
            Gets/Sets a factory type, this must implement the <see cref="T:VDS.RDF.Configuration.IObjectFactory"/> interface to be honoured
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.IGraphCollection">
            <summary>
            Interface for Graph Collections, a graph collection is a RDF dictionary therefore graphs with duplicate names will be merged together when <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/> is used
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.IRdfDictionary`2">
            <summary>
            Interface for RDF dictionaries, RDF dictionaries are special cases of a normal dictionary where values with duplicate keys are merged together rather than maintained separately whenever <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/> is called.
            </summary>
            <typeparam name="TKey">Key Type</typeparam>
            <typeparam name="TValue">Value Type</typeparam>
        </member>
        <member name="T:VDS.RDF.Collections.IRdfCollection`1">
            <summary>
            Interface for RDF Collections, RDF collections are a kind of set and therfore are required to ignore duplicates
            </summary>
            <typeparam name="T">Type</typeparam>
            <remarks>
            This simple interface is provided rather than using <see cref="T:System.Collections.Generic.ISet`1"/> because it requires a large range of complex set operations to be defined which are unecessary for our use cases.  Also we add special bulk add operations that implementations can use to optimise bulk insertions and deletions.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.IRdfCollection`1.Add(`0)">
            <summary>
            Adds an item to the collection
            </summary>
            <param name="item">Item</param>
            <returns>True if the item was added, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Collections.IRdfCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a range of items to the collection
            </summary>
            <param name="items">Items</param>
            <returns>True if any items were added, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Collections.IRdfCollection`1.Contains(`0)">
            <summary>
            Is the given item contained in the collection?
            </summary>
            <param name="item">Item</param>
            <returns>True if the item exists, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Collections.IRdfCollection`1.Remove(`0)">
            <summary>
            Removes an item from the collection
            </summary>
            <param name="item">Item</param>
            <returns>True if the item was removed, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Collections.IRdfCollection`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes a range of items from the collection
            </summary>
            <param name="items">Items</param>
            <returns>True if any item was removed, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Collections.IRdfCollection`1.Clear">
            <summary>
            Clears the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.IRdfCollection`1.Count">
            <summary>
            Gets the count of the items in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.IRdfCollection`1.IsReadOnly">
            <summary>
            Gets if the collection is ready only
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.ITripleCollection">
            <summary>
            Interface for Triple Collections, a triple collection is a set of triples thus duplicates are ignored.
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.ITripleCollection.CanModifyDuringIteration">
            <summary>
            Indicates whether the collection may be modified while an iteration is ongoing
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.ITripleCollection.HasIndexes">
            <summary>
            Indicates whether the collection has indexes
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.ThreadSafeGraphCollection">
            <summary>
            Thread Safe decorator around a Graph collection
            </summary>
            <remarks>
            <para>
            Dependings on your platform this either provides MRSW concurrency via a <see cref="T:System.Threading.ReaderWriterLockSlim"/> or exclusive access concurrency via a <see cref="T:System.Threading.Monitor"/>
            </para>
            <para>
            Thread safety is only guaranteed for graph collection level operations, it is still possible for other code to modify the stored graphs in a non-thread safe way.  This can be avoided if all graphs in the collection are <see cref="T:VDS.RDF.Graphs.ThreadSafeGraph"/> instances.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Collections.WrapperGraphCollection">
            <summary>
            Abstract decorator for Graph Collections to make it easier to add new functionality to existing implementations
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.BaseGraphCollection">
            <summary>
            Abstract Base Class for Graph Collections
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.ContainsKey(VDS.RDF.Nodes.INode)">
            <summary>
            Checks whether the Graph with the given name exists in this Graph Collection
            </summary>
            <param name="graphName">Graph name to test</param>
            <returns>True if a graph with the given name exists in the collection</returns>
            <remarks>
            The null name is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.Contains(System.Collections.Generic.KeyValuePair{VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph})">
            <summary>
            Checks whether the graph given is stored in the collection under the given name
            </summary>
            <param name="kvp">Graph name and Graph pair</param>
            <returns>True if the graph given exists in the collection under the given name, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.Add(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Adds a graph to the collection
            </summary>
            <param name="graphName">Graph name</param>
            <param name="g">Graph to add</param>
            <remarks>
            The null URI is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.Add(System.Collections.Generic.KeyValuePair{VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph})">
            <summary>
            Adds a graph to the collection
            </summary>
            <param name="kvp">Graph name and Graph pair</param>
            <remarks>
            The null name is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.Clear">
            <summary>
            Clears the contents of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.Remove(VDS.RDF.Nodes.INode)">
            <summary>
            Removes a Graph from the collection
            </summary>
            <param name="graphName">Name of the Graph to remove</param>
            <returns>True if a Graph is removed, false otherwise</returns>
            <remarks>
            The null name is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.Remove(System.Collections.Generic.KeyValuePair{VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph})">
            <summary>
            Removes a Graph from the collection only if the contents of the graph exactly match the graph stored against that name in the collection
            </summary>
            <param name="kvp">Graph name and Graph pair</param>
            <returns>True if a Graph is removed, false otherwise</returns>
            <remarks>
            The null name is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.TryGetValue(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph@)">
            <summary>
            Tries to get the graph associated with a given name from the collection
            </summary>
            <param name="graphName">Graph name</param>
            <param name="g">Graph</param>
            <returns>True if a graph with the given name exists, false otherwise</returns>
            <remarks>
            The null name is used to reference the Default Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.CopyTo(System.Collections.Generic.KeyValuePair{VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph}[],System.Int32)">
            <summary>
            Copies the contents of the collection to an array
            </summary>
            <param name="dest">Array to copy to</param>
            <param name="index">Index to start copying into the array at</param>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseGraphCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for this Collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Collections.BaseGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.BaseGraphCollection.IsReadOnly">
            <summary>
            Gets whether the collection is read only
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.BaseGraphCollection.Keys">
            <summary>
            Provides access to the names of the graphs in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.BaseGraphCollection.Values">
            <summary>
            Provides access to the graphs in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.BaseGraphCollection.Item(VDS.RDF.Nodes.INode)">
            <summary>
            Gets/Sets a graph in the collection
            </summary>
            <param name="graphName">Graph name</param>
            <returns>The graph if it exists in the collection, otherwise an error is thrown</returns>
            <remarks>
            The null name is used to reference the Default Graph
            </remarks>
        </member>
        <member name="F:VDS.RDF.Collections.WrapperGraphCollection._graphs">
            <summary>
            Underlying Graph Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperGraphCollection.#ctor">
            <summary>
            Creates a decorator around a default <see cref="T:VDS.RDF.Collections.GraphCollection"/> instance
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperGraphCollection.#ctor(VDS.RDF.Collections.IGraphCollection)">
            <summary>
            Creates a decorator around the given graph collection
            </summary>
            <param name="graphCollection">Graph Collection</param>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperGraphCollection.Add(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Adds a Graph to the collection
            </summary>
            <param name="graphName">Graph name</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperGraphCollection.ContainsKey(VDS.RDF.Nodes.INode)">
            <summary>
            Gets whether the collection contains the given Graph
            </summary>
            <param name="graphName">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperGraphCollection.Remove(VDS.RDF.Nodes.INode)">
            <summary>
            Removes a Graph from the collection
            </summary>
            <param name="graphName">Graph URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperGraphCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperGraphCollection.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Collections.WrapperGraphCollection.Item(VDS.RDF.Nodes.INode)">
            <summary>
            Gets a Graph from the collection
            </summary>
            <param name="graphName">Graph URI</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Collections.WrapperGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.WrapperGraphCollection.Keys">
            <summary>
            Gets the names of the Graphs in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.WrapperGraphCollection.Values">
            <summary>
            Gets the graphs in the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.#ctor">
            <summary>
            Creates a new Thread Safe decorator around the default <see cref="T:VDS.RDF.Collections.GraphCollection"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.#ctor(VDS.RDF.Collections.BaseGraphCollection)">
            <summary>
            Creates a new Thread Safe decorator around the supplied graph collection
            </summary>
            <param name="graphCollection">Graph Collection</param>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.EnterWriteLock">
            <summary>
            Enters the write lock
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.ExitWriteLock">
            <summary>
            Exits the write lock
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.EnterReadLock">
            <summary>
            Enters the read lock
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.ExitReadLock">
            <summary>
            Exits the read lock
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.ContainsKey(VDS.RDF.Nodes.INode)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection
            </summary>
            <param name="graphName">Graph name to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.Add(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="graphName">Name of the graph to add to</param>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.Remove(VDS.RDF.Nodes.INode)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphName">Name of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeGraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
            <remarks>Invokes the <see cref="!:IGraph.Dispose">Dispose()</see> method of all Graphs contained in the Collection</remarks>
        </member>
        <member name="P:VDS.RDF.Collections.ThreadSafeGraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.ThreadSafeGraphCollection.Keys">
            <summary>
            Provides access to the Graph URIs of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.ThreadSafeGraphCollection.Item(VDS.RDF.Nodes.INode)">
            <summary>
            Gets a Graph from the Collection
            </summary>
            <param name="graphName">Graph name</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Collections.ThreadSafeTripleCollection">
            <summary>
            Thread Safe decorator for triple collections
            </summary>
            <remarks>
            Depending on the platform this either uses <see cref="T:System.Threading.ReaderWriterLockSlim"/> to provide MRSW concurrency or it uses <see cref="T:System.Threading.Monitor"/> to provide exclusive access concurrency, either way usage is thread safe
            </remarks>
            <threadsafety instance="true">This decorator provides thread safe access to any underlying triple collection</threadsafety>
        </member>
        <member name="T:VDS.RDF.Collections.WrapperTripleCollection">
            <summary>
            Abstract decorator for Triple Collections to make it easier to add additional functionality to existing collections
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.BaseTripleCollection">
            <summary>
            Abstract Base Class for Triple Collections
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.Add(VDS.RDF.Graphs.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
            <remarks>Adding a Triple that already exists should be permitted though it is not necessary to persist the duplicate to underlying storage</remarks>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.AddRange(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Adds a range of triples to the collection
            </summary>
            <param name="ts">Triples to add</param>
            <returns>True if any triples are added</returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.Contains(VDS.RDF.Graphs.Triple)">
            <summary>
            Determines whether a given Triple is in the collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple is contained in the collection</returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.Remove(VDS.RDF.Graphs.Triple)">
            <summary>
            Removes a Triple from the Collection
            </summary>
            <param name="t">Triple to remove</param>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.RemoveRange(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Removes a range of Triples from the Collection
            </summary>
            <param name="ts">Triples to remove</param>
            <returns>True if any triples are removed, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.Clear">
            <summary>
            Clears the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.WithSubject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Triples with the given Subject
            </summary>
            <param name="subj">ubject to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.WithPredicate(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Triples with the given Predicate
            </summary>
            <param name="pred">Predicate to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.WithObject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Triples with the given Object
            </summary>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.WithSubjectPredicate(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Triples with the given Subject Predicate pair
            </summary>
            <param name="subj">Subject to lookup</param>
            <param name="pred">Predicate to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.WithPredicateObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Triples with the given Predicate Object pair
            </summary>
            <param name="pred">Predicate to lookup</param>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.WithSubjectObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Triples with the given Subject Object pair
            </summary>
            <param name="subj">Subject to lookup</param>
            <param name="obj">Object to lookup</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.Dispose">
            <summary>
            Diposes of a Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.GetEnumerator">
            <summary>
            Gets the typed Enumerator for the Triple Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the non-generic Enumerator for the Triple Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.StartBatch(System.Collections.Specialized.NotifyCollectionChangedAction)">
            <summary>
            Signals the start of a batch add/remove operation.  Single triple events will be suppressed and queued up until <see cref="M:VDS.RDF.Collections.BaseTripleCollection.EndBatch"/> is called
            </summary>
            <param name="action">Action, must be add/remove</param>
        </member>
        <member name="M:VDS.RDF.Collections.BaseTripleCollection.EndBatch">
            <summary>
            Signals the end of a batch add/remove operation, queued events will now fire as a single event
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.BaseTripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.BaseTripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.BaseTripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.BaseTripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="F:VDS.RDF.Collections.WrapperTripleCollection._triples">
            <summary>
            Underlying Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.#ctor">
            <summary>
            Creates a new decorator over the default <see cref="T:VDS.RDF.Collections.TreeIndexedTripleCollection"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.#ctor(VDS.RDF.Collections.ITripleCollection)">
            <summary>
            Creates a new decorator around the given triple collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.Add(VDS.RDF.Graphs.Triple)">
            <summary>
            Adds a triple to the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.Contains(VDS.RDF.Graphs.Triple)">
            <summary>
            Gets whether the collection contains the given Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.Remove(VDS.RDF.Graphs.Triple)">
            <summary>
            Deletes a triple from the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.WithObject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with the given object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.WithPredicate(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with the given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.WithPredicateObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with the given predicate and object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.WithSubject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with the given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.WithSubjectObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with the given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.WrapperTripleCollection.WithSubjectPredicate(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with the given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Collections.WrapperTripleCollection.Count">
            <summary>
            Counts the triples in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.WrapperTripleCollection.ObjectNodes">
            <summary>
            Gets the object nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.WrapperTripleCollection.PredicateNodes">
            <summary>
            Gets the predicate nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.WrapperTripleCollection.SubjectNodes">
            <summary>
            Gets the subject nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.#ctor">
            <summary>
            Creates a new thread safe triple collection which wraps a new instance of the default unindexed <see cref="T:VDS.RDF.Collections.TripleCollection"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.#ctor(VDS.RDF.Collections.BaseTripleCollection)">
            <summary>
            Creates a new thread safe triple collection which wraps the provided triple collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.EnterWriteLock">
            <summary>
            Enters the write lock
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.ExitWriteLock">
            <summary>
            Exists the write lock
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.EnterReadLock">
            <summary>
            Enters the read lock
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.ExitReadLock">
            <summary>
            Exists the read lock
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.Add(VDS.RDF.Graphs.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.Contains(VDS.RDF.Graphs.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.Remove(VDS.RDF.Graphs.Triple)">
            <summary>
            Deletes a Triple from the Collection
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist has no effect and gives no error</remarks>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.WithObject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all triples with the given Object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.WithPredicate(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all triples with the given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.WithPredicateObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all triples with the given predicate object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.WithSubject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with the given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.WithSubjectObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with the given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.WithSubjectPredicate(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all triples with the given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.ThreadSafeTripleCollection.Dispose">
            <summary>
            Disposes of a Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.ThreadSafeTripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.ThreadSafeTripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collectio
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.ThreadSafeTripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.ThreadSafeTripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.SubTreeIndexedTripleCollection">
            <summary>
            An indexed triple collection that uses our <see cref="T:VDS.Common.Collections.MultiDictionary`2"/> and <see cref="T:VDS.Common.Trees.BinaryTree`3"/> implementations under the hood for the index structures
            </summary>
            <remarks>
            <para>
            A variation on <see cref="T:VDS.RDF.Collections.TreeIndexedTripleCollection"/> which structures the indexes slightly differently, this may give differing performance and reduced memory usage in some scenarios.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Index(VDS.RDF.Graphs.Triple)">
            <summary>
            Indexes a Triple
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Index(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.Nodes.INode,VDS.Common.Collections.MultiDictionary{VDS.RDF.Graphs.Triple,System.Collections.Generic.List{VDS.RDF.Graphs.Triple}}},System.Func{VDS.RDF.Graphs.Triple,System.Int32},System.Collections.Generic.IComparer{VDS.RDF.Graphs.Triple})">
            <summary>
            Helper for indexing triples
            </summary>
            <param name="n">Node to index by</param>
            <param name="t">Triple</param>
            <param name="index">Index to insert into</param>
            <param name="comparer">Comparer for the Index</param>
            <param name="hashFunc">Hash Function for the Index</param>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Unindex(VDS.RDF.Graphs.Triple)">
            <summary>
            Unindexes a triple
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Unindex(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.Nodes.INode,VDS.Common.Collections.MultiDictionary{VDS.RDF.Graphs.Triple,System.Collections.Generic.List{VDS.RDF.Graphs.Triple}}})">
            <summary>
            Helper for unindexing triples
            </summary>
            <param name="n">Node to index by</param>
            <param name="t">Triple</param>
            <param name="index">Index to remove from</param>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Add(VDS.RDF.Graphs.Triple)">
            <summary>
            Adds a Triple to the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Contains(VDS.RDF.Graphs.Triple)">
            <summary>
            Checks whether the collection contains a given Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Remove(VDS.RDF.Graphs.Triple)">
            <summary>
            Deletes a triple from the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.WithObject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.WithPredicate(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.WithSubject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.WithPredicateObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given predicate and object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.WithSubjectObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.WithSubjectPredicate(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.SubTreeIndexedTripleCollection.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Collections.SubTreeIndexedTripleCollection.Count">
            <summary>
            Gets the count of triples in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.SubTreeIndexedTripleCollection.ObjectNodes">
            <summary>
            Gets the Object Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.SubTreeIndexedTripleCollection.PredicateNodes">
            <summary>
            Gets the Predicate Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.SubTreeIndexedTripleCollection.SubjectNodes">
            <summary>
            Gets the Subject Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.TreeIndexedTripleCollection">
            <summary>
            An indexed triple collection that uses our <see cref="T:VDS.Common.Collections.MultiDictionary`2"/> and <see cref="T:VDS.Common.Trees.BinaryTree`3"/> implementations under the hood for the index structures
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.#ctor">
            <summary>
            Creates a new Tree Indexed triple collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.#ctor(VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new Tree Indexed triple collection
            </summary>
            <param name="compoundIndexMode">Mode to use for compound indexes</param>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,VDS.Common.Collections.MultiDictionaryMode)">
            <summary>
            Creates a new Tree Indexed triple collection with the given Indexing options
            </summary>
            <param name="subjIndex">Whether to create a subject index</param>
            <param name="predIndex">Whether to create a predicate index</param>
            <param name="objIndex">Whether to create an object index</param>
            <param name="subjPredIndex">Whether to create a subject predicate index</param>
            <param name="subjObjIndex">Whether to create a subject object index</param>
            <param name="predObjIndex">Whether to create a predicate object index</param>
            <param name="compoundIndexMode">Mode to use for compound indexes</param>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.Index(VDS.RDF.Graphs.Triple)">
            <summary>
            Indexes a Triple
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.IndexSimple(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.Nodes.INode,System.Collections.Generic.List{VDS.RDF.Graphs.Triple}})">
            <summary>
            Helper for indexing triples
            </summary>
            <param name="n">Node to index by</param>
            <param name="t">Triple</param>
            <param name="index">Index to insert into</param>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.IndexCompound(VDS.RDF.Graphs.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.Graphs.Triple,System.Collections.Generic.List{VDS.RDF.Graphs.Triple}})">
            <summary>
            Helper for indexing triples
            </summary>
            <param name="t">Triple to index by</param>
            <param name="index">Index to insert into</param>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.Unindex(VDS.RDF.Graphs.Triple)">
            <summary>
            Unindexes a triple
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.UnindexSimple(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.Nodes.INode,System.Collections.Generic.List{VDS.RDF.Graphs.Triple}})">
            <summary>
            Helper for unindexing triples
            </summary>
            <param name="n">Node to index by</param>
            <param name="t">Triple</param>
            <param name="index">Index to remove from</param>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.UnindexCompound(VDS.RDF.Graphs.Triple,VDS.Common.Collections.MultiDictionary{VDS.RDF.Graphs.Triple,System.Collections.Generic.List{VDS.RDF.Graphs.Triple}})">
            <summary>
            Helper for unindexing triples
            </summary>
            <param name="t">Triple</param>
            <param name="index">Index to remove from</param>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.Add(VDS.RDF.Graphs.Triple)">
            <summary>
            Adds a Triple to the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.Contains(VDS.RDF.Graphs.Triple)">
            <summary>
            Checks whether the collection contains a given Triple
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.Remove(VDS.RDF.Graphs.Triple)">
            <summary>
            Removes a triple from the collection
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.WithObject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given object
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.WithPredicate(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given predicate
            </summary>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.WithSubject(VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given subject
            </summary>
            <param name="subj">Subject</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.WithPredicateObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given predicate and object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.WithSubjectObject(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given subject and object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.WithSubjectPredicate(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the triples with a given subject and predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.TreeIndexedTripleCollection.GetEnumerator">
            <summary>
            Gets the enumerator for the collection
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Collections.TreeIndexedTripleCollection.Count">
            <summary>
            Gets the count of triples in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.TreeIndexedTripleCollection.ObjectNodes">
            <summary>
            Gets the Object Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.TreeIndexedTripleCollection.PredicateNodes">
            <summary>
            Gets the Predicate Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.TreeIndexedTripleCollection.SubjectNodes">
            <summary>
            Gets the Subject Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.ConfigurationSerializationContext">
            <summary>
            Context Class for writing serializing Configuration information
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationSerializationContext.#ctor">
            <summary>
            Creates a new Serialization Context
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.ConfigurationSerializationContext.#ctor(VDS.RDF.Graphs.IGraph)">
            <summary>
            Creates a new Serialization Context
            </summary>
            <param name="g">Base Configuration Graph</param>
        </member>
        <member name="P:VDS.RDF.Configuration.ConfigurationSerializationContext.Graph">
            <summary>
            Gets the Graph to which Configuration information should be written
            </summary>
        </member>
        <member name="P:VDS.RDF.Configuration.ConfigurationSerializationContext.NextSubject">
            <summary>
            Gets/Sets the next subject to be used
            </summary>
            <remarks>
            <para>
            Always returns a Blank Node if none is currently explicitly specified
            </para>
            <para>
            Used to link objects together when you want some subsidiary object to serialize it's configuration and link that to the configuration you are currently serializing
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ConfigurationNamespace">
            <summary>
            Configuration Namespace URI
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyType">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyImports">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyConfigure">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyEnabled">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUser">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyPassword">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyCredentials">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUseCredentialsForProxy">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyServer">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyPort">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyDatabase">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyCatalog">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyStore">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyQueryPath">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUpdatePath">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyReadOnly">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyEnableUpdates">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyAsync">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyLoadMode">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyEncryptConnection">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertySkipParsing">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyStorageProvider">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyQueryProcessor">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUpdateProcessor">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyProtocolProcessor">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUsingDataset">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUsingStore">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUsingGraph">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUsingTripleCollection">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUsingGraphCollection">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyFromFile">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyFromEmbedded">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyFromUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyFromString">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyFromDataset">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyFromStore">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyFromGraph">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyWithUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyAssignUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyEndpoint">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyEndpointUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyQueryEndpointUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUpdateEndpointUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyQueryEndpoint">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUpdateEndpoint">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyDefaultGraphUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyNamedGraphUri">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUnionDefaultGraph">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyProxy">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyReasoner">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyOwlReasoner">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyUserGroup">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyMember">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyRequiresAuthentication">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyPermissionModel">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyAllow">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyDeny">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyAction">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyEnableCors">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertySyntax">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyTimeout">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyPartialResults">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyShowErrors">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyHaltOnError">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyShowQueryForm">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyShowUpdateForm">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyDefaultQueryFile">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyDefaultUpdateFile">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyIntroFile">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyStylesheet">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyCacheDuration">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyCacheSliding">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyExpressionFactory">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyFunctionFactory">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyDescribeAlgorithm">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyServiceDescription">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyQueryOptimiser">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyAlgebraOptimiser">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyCompressionLevel">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyPrettyPrinting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyHighSpeedWriting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyDtdWriting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyAttributeWriting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyMultiThreadedWriting">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.PropertyImportNamespacesFrom">
            <summary>
            URI Constants for configuration properties
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassObjectFactory">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassTripleStore">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassGraphCollection">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassGraph">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassTripleCollection">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassStorageServer">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassStorageProvider">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassHttpHandler">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlEndpoint">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlQueryEndpoint">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlUpdateEndpoint">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlQueryProcessor">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlUpdateProcessor">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlHttpProtocolProcessor">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlExpressionFactory">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlPropertyFunctionFactory">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlDataset">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassQueryOptimiser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassAlgebraOptimiser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlOperator">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassReasoner">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassOwlReasoner">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassProxy">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassUserGroup">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassUser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassPermission">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassRdfParser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassDatasetParser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlResultsParser">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassRdfWriter">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassDatasetWriter">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="F:VDS.RDF.Configuration.ConfigurationVocabulary.ClassSparqlResultsWriter">
            <summary>
            URI Constants for configuration classes
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.IObjectFactory">
            <summary>
            Interface for Object Factories which are factory classes that can create Objects based on configuration information in a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IObjectFactory.TryLoadObject(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,System.Type,System.Object@)">
            <summary>
            Attempts to load an Object of the given type identified by the given Node and returned as the Type that this loader generates
            </summary>
            <param name="g">Configuration Graph</param>
            <param name="objNode">Object Node</param>
            <param name="targetType">Target Type</param>
            <param name="obj">Created Object</param>
            <returns>True if the loader succeeded in creating an Object</returns>
            <remarks>
            <para>
            The Factory should not throw an error if some required configuration is missing as another factory further down the processing chain may still be able to create the object.  If the factory encounters errors and all the required configuration information is present then that error should be thrown i.e. class instantiation throws an error or a call to load an object that this object requires fails.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.IObjectFactory.CanLoadObject(System.Type)">
            <summary>
            Returns whether this Factory is capable of creating objects of the given type
            </summary>
            <param name="t">Target Type</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.RdfException">
            <summary>
            Class for representing errors with RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.RdfException.#ctor(System.String)">
            <summary>
            Creates a new RDF Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.RdfException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Configuration.DotNetRdfConfigurationException">
            <summary>
            Class for representing errors with dotNetRDF Configuration
            </summary>
            <remarks>
            <para>
            Configuration exceptions are thrown when the user tries to load objects using the <see cref="!:ConfigurationLoader">ConfigurationLoader</see> and their is insufficient/invalid information to load the desired object
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Configuration.DotNetRdfConfigurationException.#ctor(System.String)">
            <summary>
            Creates a new dotNetRDF Configuration Exception
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Configuration.DotNetRdfConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new dotNetRDF Configuration Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Nodes.NodeValueException">
            <summary>
            Exception that may occur when working with <see cref="T:VDS.RDF.Nodes.IValuedNode"/> instances
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeValueException.#ctor(System.String)">
            <summary>
            Creates a new Node Value Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeValueException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new Node Value Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Ontology.RdfOntologyException">
            <summary>
            Class for representing errors with Ontologies
            </summary>
        </member>
        <member name="M:VDS.RDF.Ontology.RdfOntologyException.#ctor(System.String)">
            <summary>
            Creates a new RDF Ontology Exception with the given message
            </summary>
            <param name="errorMsg">Error message</param>
        </member>
        <member name="M:VDS.RDF.Ontology.RdfOntologyException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Ontology Exception with the given message and inner exception
            </summary>
            <param name="errorMsg">Error message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.Writing.RdfOutputException">
            <summary>
            Class of exceptions that may occur when outputting RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.RdfOutputException.#ctor(System.String)">
            <summary>
            Creates a new RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfOutputException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
            <param name="cause">Exception that caused this Exception</param>
        </member>
        <member name="T:VDS.RDF.Writing.RdfThreadedOutputException">
            <summary>
            Class of exceptions that may occur when doing multi-threaded output of RDF
            </summary>
            <remarks>
            <para>
            Used when a process may result in multiple errors from different threads
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.RdfThreadedOutputException.#ctor(System.String)">
            <summary>
            Creates a new Threaded RDF Output Exception
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfThreadedOutputException.AddException(System.Exception)">
            <summary>
            Adds an Exception to the list of Inner Exceptions
            </summary>
            <param name="ex">Exception</param>
        </member>
        <member name="P:VDS.RDF.Writing.RdfThreadedOutputException.InnerExceptions">
            <summary>
            Gets the enumeration of Exceptions
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.RdfWriterSelectionException">
            <summary>
            Class for errors in selecting an appropriate Writer to output RDF with
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.RdfWriterSelectionException.#ctor(System.String)">
            <summary>
            Creates a new RDF Writer Selection Exception with the given Message
            </summary>
            <param name="errorMsg">Error Message</param>
        </member>
        <member name="M:VDS.RDF.Writing.RdfWriterSelectionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new RDF Writer Selection Exception with the given Message and Inner Exception
            </summary>
            <param name="errorMsg">Error Message</param>
            <param name="cause">Inner Exception</param>
        </member>
        <member name="T:VDS.RDF.GraphExtensions">
            <summary>
            Extension functions for working with graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriples(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Selects all Triples which contain the given Node
            </summary>
            <param name="n">Node</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriples(VDS.RDF.Graphs.IGraph,System.Uri)">
            <summary>
            Selects all Triples which have a URI Node with the given URI
            </summary>
            <param name="uri">URI</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithObject(VDS.RDF.Graphs.IGraph,System.Uri)">
            <summary>
            Selects all Triples where the Object is a URI Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithObject(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Selects all Triples where the Object is a given Node
            </summary>
            <param name="n">Node</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithPredicate(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Selects all Triples where the Predicate is a given Node
            </summary>
            <param name="n">Node</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithPredicate(VDS.RDF.Graphs.IGraph,System.Uri)">
            <summary>
            Selects all Triples where the Predicate is a Uri Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithSubject(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Selects all Triples where the Subject is a given Node
            </summary>
            <param name="n">Node</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithSubject(VDS.RDF.Graphs.IGraph,System.Uri)">
            <summary>
            Selects all Triples where the Subject is a Uri Node with the given Uri
            </summary>
            <param name="u">Uri</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithSubjectPredicate(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Selects all Triples with the given Subject and Predicate
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithSubjectObject(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Selects all Triples with the given Subject and Object
            </summary>
            <param name="subj">Subject</param>
            <param name="obj">Object</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.GetTriplesWithPredicateObject(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Selects all Triples with the given Predicate and Object
            </summary>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.Assert(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Asserts a new Triple in the Graph
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <remarks>Handy method which means you can assert a Triple by specifying the Subject, Predicate and Object without having to explicity declare a new Triple</remarks>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.Retract(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="g">Graph to retract from</param>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <remarks>Handy method which means you can retract a Triple by specifying the Subject, Predicate and Object without having to explicity declare a new Triple</remarks>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.IsIsomorphicWith(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)">
            <summary>
            Checks whether a Graph is equivalent (isomorphic) to another Graph
            </summary>
            <param name="g">Graph</param>
            <param name="other">Graph to compare with for equivalence</param>
            <returns>True if graphs are isomorphic, false otherwise</returns>
            <remarks>
            <para>
            Graphs are considered equivalent or more formally isomorphic if there is a mapping such that every sub-graph that contains a set of blank nodes may be mapped to an equivalent sub-graph in the other graph.
            </para>
            <para>
            Please see the <see cref="T:VDS.RDF.Graphs.Utilities.GraphMatcher"/> class for notes on the isomorphism algorithm used
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.IsIsomorphicWith(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode}@)">
            <summary>
            Checks whether a Graph is equivalent (isomorphic) to another Graph and if so returns the mapping of Blank Nodes
            </summary>
            <param name="g">Graph</param>
            <param name="other">Graph to compare with for equivalence</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns>True if graphs are isomorphic, false otherwise</returns>
            <remarks>
            <para>
            Graphs are considered equivalent or more formally isomorphic if there is a mapping such that every sub-graph that contains a set of blank nodes may be mapped to an equivalent sub-graph in the other graph.
            </para>
            <para>
            Please see the <see cref="T:VDS.RDF.Graphs.Utilities.GraphMatcher"/> class for notes on the isomorphism algorithm used
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.IsSubGraphOf(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)">
            <summary>
            Checks whether a Graph is a sub-graph of another Graph
            </summary>
            <param name="g">Graph</param>
            <param name="superGraph">Graph that should contain <paramref name="g"/> as a sub-graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.IsSubGraphOf(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode}@)">
            <summary>
            Checks whether a Graph is a sub-graph of another Graph
            </summary>
            <param name="g">Graph</param>
            <param name="superGraph">Graph that should contain <paramref name="g"/> as a sub-graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.HasSubGraph(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)">
            <summary>
            Checks whether a Graph has another Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <param name="subGraph">Graph that should be contained in <paramref name="g"/> as a sub-graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.HasSubGraph(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode}@)">
            <summary>
            Checks whether a Graph has another Graph as a sub-graph
            </summary>
            <param name="g">Graph</param>
            <param name="subGraph">Graph that should be contained in <paramref name="g"/> as a sub-graph</param>
            <param name="mapping">Mapping of Blank Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.GraphExtensions.Difference(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)">
            <summary>
            Calculates the difference between two graphs
            </summary>
            <param name="g">Graph</param>
            <param name="other">Graph to compare against</param>
            <returns></returns>
            <remarks>
            <para>
            Produces a report which shows the changes that must be made to <paramref name="g"/> in order to produce <paramref name="other"/> or if they represent the same graph reports that
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Graphs.GraphAccessMode">
            <summary>
            Possible access modes for a graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.GraphAccessMode.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.GraphAccessMode.Read">
            <summary>
            Read
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.GraphAccessMode.Append">
            <summary>
            Append
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.GraphAccessMode.Delete">
            <summary>
            Delete
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.GraphAccessMode.Write">
            <summary>
            Write i.e. append and delete
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.GraphAccessMode.ReadWrite">
            <summary>
            Read Write i.e. read and write
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.IEventedGraph">
            <summary>
            Interface for graphs that support events, events are provided via implementation of the standard <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> interface
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.IGraph">
            <summary>
            Interface for RDF Graphs
            </summary>
            <remarks>
            <para>
            Most implementations will probably want to inherit from the abstract class <see cref="T:VDS.RDF.Graphs.BaseGraph">BaseGraph</see> since it contains reference implementations of various algorithms (Graph Equality/Graph Difference/Sub-Graph testing etc) which will save considerable work in implementation and ensure consistent behaviour of some methods across implementations.
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Nodes.INodeFactory">
            <summary>
            Interface for classes which can create Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateBlankNode">
            <summary>
            Creates a Blank Node with a new automatically generated ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateBlankNode(System.Guid)">
            <summary>
            Creates a Blank Node with the given ID
            </summary>
            <param name="id">ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateGraphLiteralNode">
            <summary>
            Creates a Graph Literal Node which represents the empty Subgraph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateGraphLiteralNode(VDS.RDF.Graphs.IGraph)">
            <summary>
            Creates a Graph Literal Node which represents the given Subgraph
            </summary>
            <param name="subgraph">Subgraph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a Literal Node with the given Value and Data Type
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="datatype">Data Type URI of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateLiteralNode(System.String)">
            <summary>
            Creates a Literal Node with the given Value
            </summary>
            <param name="literal">Value of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a Literal Node with the given Value and Language
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="langspec">Language Specifier for the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateUriNode(System.Uri)">
            <summary>
            Creates a URI Node for the given URI
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INodeFactory.CreateVariableNode(System.String)">
            <summary>
            Creates a Variable Node for the given Variable Name
            </summary>
            <param name="varname"></param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.INodeFactory.CreatesImplicitlyTypedLiterals">
            <summary>
            Indicates whether this factory produces RDF 1.1 literals
            </summary>
            <remarks>
            If true then calling <see cref="M:VDS.RDF.Nodes.INodeFactory.CreateLiteralNode(System.String)"/> will produce a literal typed as xsd:string and calling <see cref="M:VDS.RDF.Nodes.INodeFactory.CreateLiteralNode(System.String,System.String)"/> will produce a literal typed as rdf:langString.  If false then literals are created only with the fields provided.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.Assert(VDS.RDF.Graphs.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">A Triple</param>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Asserts an Enumerable of Triples in the Graph
            </summary>
            <param name="ts">An Enumerable of Triples</param>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.Retract(VDS.RDF.Graphs.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">A Triple</param>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Retracts an Enumerable of Triples from the Graph
            </summary>
            <param name="ts">Enumerable of Triples</param>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.Clear">
            <summary>
            Clears the graph of all data
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.CreateUriNode(System.String)">
            <summary>
            Creates a URI Node for the given prefixed name using the graphs associated namespace map to resolve the prefixed name
            </summary>
            <param name="prefixedName">Prefixed name</param>
            <returns>URI Node</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.Find(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Finds triples matching the given search criteria i.e. those where the given nodes occur in the appropriate position(s).  Null values are treated as wildcards for a position.
            </summary>
            <param name="s">Subject</param>
            <param name="p">Predicate</param>
            <param name="o">Object</param>
            <returns>Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.ContainsTriple(VDS.RDF.Graphs.Triple)">
            <summary>
            Gets whether a given Triple is in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraph.ToDataTable">
            <summary>
            Converts the Graph into a DataTable
            </summary>
            <returns></returns>
            <remarks>
            <strong>Warning:</strong> Not available under builds which remove the Data Storage layer from dotNetRDF e.g. Silverlight
            </remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraph.Count">
            <summary>
            Gets the number of triples in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraph.IsEmpty">
            <summary>
            Gets whether a Graph is Empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraph.Namespaces">
            <summary>
            Gets the Namespace Map for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraph.Vertices">
            <summary>
            Gets the nodes that are used as vertices in the graph i.e. those which occur in the subject or object position of a triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraph.Edges">
            <summary>
            Gets the nodes that are used as edges in the graph i.e. those which occur in the predicate position of a triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraph.Triples">
            <summary>
            Gets the triples present in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraph.Quads">
            <summary>
            Gets the quads present in the graph
            </summary>
            <remarks>Since a graph does not itself have a time quads retrieved in this way have the <see cref="P:VDS.RDF.Graphs.Quad.Graph"/> field set to <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/></remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraph.Capabilities">
            <summary>
            Gets the capabilities of the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IEventedGraph.HasEvents">
            <summary>
            Indicates whether a graph actually has events
            </summary>
            <remarks>
            While generally speaking use of this interface will be sufficient to indicate that a graph supports events in some cases where complex graph types such as decorators, unions, etc are used the availability of events may be dictated by the underlying graphs even if the wrapper is capable of providing them.  Thus users intending to consume events should check that this method returns true.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Graphs.IGraphCapabilities">
            <summary>
            Provides information about a graphs capabilities
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraphCapabilities.AccessMode">
            <summary>
            Gets the access mode for the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraphCapabilities.CanModifyDuringIteration">
            <summary>
            Indicates whether a graph can be modified during iteration
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraphCapabilities.HasIndexes">
            <summary>
            Indicates whether a graph has indexes
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.IQuadStore">
            <summary>
            Interface for Quad Stores
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.IQuadStore.Add(VDS.RDF.Graphs.Quad)">
            <summary>
            Adds a Quad to the Store
            </summary>
            <param name="q">Quad</param>
        </member>
        <member name="M:VDS.RDF.Graphs.IQuadStore.Clear(VDS.RDF.Nodes.INode)">
            <summary>
            Clears all quads with the given graph name
            </summary>
            <param name="graphName">Graph name</param>
            <remarks>
            <em>null</em> or <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> may be used to access the default unnamed graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.IQuadStore.Remove(VDS.RDF.Graphs.Quad)">
            <summary>
            Removes a Quad from the store
            </summary>
            <param name="q">Quad</param>
        </member>
        <member name="M:VDS.RDF.Graphs.IQuadStore.Contains(VDS.RDF.Graphs.Quad)">
            <summary>
            Is the given Quad contained in the store?
            </summary>
            <param name="q">Quad</param>
            <returns>True if present, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.IQuadStore.Find(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Find any quads matching the given search criteria with any graph name, null is treated as a wildcard.  Implementations should not retain duplicates though it should be impossible to have duplicate quads in the first place.
            </summary>
            <param name="s">Subject</param>
            <param name="p">Predicate</param>
            <param name="o">Object</param>
            <returns>Enumerable of quads</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.IQuadStore.Find(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Finds any quads matching the given search criteria, null is treated as a wildcard.  Implementations should not retain duplicates though it should be impossible to have duplicate quads in the first place.
            </summary>
            <param name="g">Graph name</param>
            <param name="s">Subject</param>
            <param name="p">Predicate</param>
            <param name="o">Object</param>
            <returns>Enumerable of quads</returns>
            <remarks>
            <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> <strong>must</strong> be used to access the default unnamed graph since <em>null</em> is treated as a wildcard for this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.IQuadStore.HasGraph(VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether the store has any quads with the specified graph name
            </summary>
            <param name="graphName">Graph name</param>
            <returns>True if the any relevant quads exist in the store, false otherwise</returns>
            <remarks>
            <em>null</em> or <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> may be used to access the default unnamed graph
            </remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.IQuadStore.Quads">
            <summary>
            Get all Quads in the store
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IQuadStore.GraphNames">
            <summary>
            Gets the names of the Graphs in the Store
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.ITransactionalGraph">
            <summary>
            Interface for RDF Graphs which provide Transactions i.e. changes to them can be performed in a transaction and committed or rolled back as desired
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ITransactionalGraph.Begin">
            <summary>
            Begins a transaction
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ITransactionalGraph.Commit">
            <summary>
            Commits a transaction
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ITransactionalGraph.Rollback">
            <summary>
            Aborts and rollbacks a transaction
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.WrapperGraph">
            <summary>
            Abstract decorator for Graphs to make it easier to layer functionality on top of existing implementations
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.WrapperGraph._g">
            <summary>
            Underlying Graph this is a wrapper around
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.#ctor">
            <summary>
            Creates a wrapper around the default Graph implementation, primarily required only for deserialization and requires that the caller call <see cref="M:VDS.RDF.Graphs.WrapperGraph.AttachEventHandlers"/> to properly wire up event handling
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.#ctor(VDS.RDF.Graphs.IGraph)">
            <summary>
            Creates a new wrapper around the given Graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.Assert(VDS.RDF.Graphs.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Asserts Triples in the Graph
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.Retract(VDS.RDF.Graphs.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Retracts Triples from the Graph
            </summary>
            <param name="ts">Triples</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.Clear">
            <summary>
            Clears the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateBlankNode">
            <summary>
            Creates a new Blank Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateBlankNode(System.Guid)">
            <summary>
            Creates a new blank node with the given ID
            </summary>
            <param name="id">ID</param>
            <returns>Blank node</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateGraphLiteralNode(VDS.RDF.Graphs.IGraph)">
            <summary>
            Creates a new Graph Literal Node with the given sub-graph
            </summary>
            <param name="subgraph">Sub-graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateGraphLiteralNode">
            <summary>
            Creates a new Graph Literal Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateLiteralNode(System.String)">
            <summary>
            Creates a new Literal Node
            </summary>
            <param name="literal">Value</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a new Literal Node with the given Datatype
            </summary>
            <param name="literal">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a new Literal Node with the given Language
            </summary>
            <param name="literal">Value</param>
            <param name="langspec">Language</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateUriNode(System.String)">
            <summary>
            Creates a new URI Node from a QName
            </summary>
            <param name="prefixedName">QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateUriNode(System.Uri)">
            <summary>
            Creates a new URI Node
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.CreateVariableNode(System.String)">
            <summary>
            Creates a new Variable Node
            </summary>
            <param name="varname">Variable Name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.ContainsTriple(VDS.RDF.Graphs.Triple)">
            <summary>
            Gets whether a given Triple exists in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.Equals(System.Object)">
            <summary>
            Determines whether a Graph is equal to another Object
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
            <remarks>
            <para>
            A Graph can only be equal to another Object which is an <see cref="T:VDS.RDF.Graphs.IGraph">IGraph</see>
            </para>
            <para>
            Graph Equality is determined by a somewhat complex algorithm which is explained in the remarks of the other overload for Equals
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.ToDataTable">
            <summary>
            Converts the wrapped graph into a DataTable
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.HandleCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Helper method uses to handle the <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> from the wrapped graph and propagate it to this graphs <see cref="E:VDS.RDF.Graphs.WrapperGraph.CollectionChanged"/> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.AttachEventHandlers">
            <summary>
            Attaches event handles to the underlying graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.Dispose">
            <summary>
            Disposes of the wrapper and in doing so disposes of the underlying graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the Serialization Information
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.GetSchema">
            <summary>
            Gets the Schema for XML serialization
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Graphs.WrapperGraph.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.Count">
            <summary>
            Gets the number of triples in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.IsEmpty">
            <summary>
            Gets whether the Graph is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.Namespaces">
            <summary>
            Gets the Namespace Map for the Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.Vertices">
            <summary>
            Gets the nodes that are used as vertices in the graph i.e. those which occur in the subject or object position of a triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.Edges">
            <summary>
            Gets the nodes that are used as edges in the graph i.e. those which occur in the predicate position of a triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.Triples">
            <summary>
            Gets the triples in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.Quads">
            <summary>
            Gets the quads in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.CreatesImplicitlyTypedLiterals">
            <summary>
            Indicates whether this factory produces RDF 1.1 literals
            </summary>
            <remarks>
            If true then calling <see cref="M:VDS.RDF.Graphs.WrapperGraph.CreateLiteralNode(System.String)"/> will produce a literal typed as xsd:string and calling <see cref="M:VDS.RDF.Graphs.WrapperGraph.CreateLiteralNode(System.String,System.String)"/> will produce a literal typed as rdf:langString.  If false then literals are created only with the fields provided.
            </remarks>
        </member>
        <member name="E:VDS.RDF.Graphs.WrapperGraph.CollectionChanged">
            <summary>
            Event which is raised when the graph changes
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.WrapperGraph.HasEvents">
            <summary>
            Gets whether the graph has events
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.Utilities.TripleCollectionCapabilities">
            <summary>
            Graph capabilities for graphs based upon triple collections
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.TripleCollectionCapabilities.#ctor(VDS.RDF.Collections.ITripleCollection,VDS.RDF.Graphs.GraphAccessMode)">
            <summary>
            Creates a new set of capabilities
            </summary>
            <param name="ts">Triple collection</param>
            <param name="mode">Access mode</param>
        </member>
        <member name="T:VDS.RDF.ListExtensions">
            <summary>
            Extension methods to make working with RDF lists easier
            </summary>
        </member>
        <member name="M:VDS.RDF.ListExtensions.AssertList``1(VDS.RDF.Graphs.IGraph,System.Collections.Generic.IEnumerable{``0},System.Func{``0,VDS.RDF.Nodes.INode})">
            <summary>
            Asserts a list as a RDF collection and returns the node that represents the root of the RDF collection
            </summary>
            <typeparam name="T">Type of Objects</typeparam>
            <param name="g">Graph to assert in</param>
            <param name="objects">Objects to place in the collection</param>
            <param name="mapFunc">Mapping from Object Type to <see cref="T:VDS.RDF.Nodes.INode">INode</see></param>
            <returns>
            Either the blank node which is the root of the collection or <strong>rdf:nil</strong> for empty collections
            </returns>
        </member>
        <member name="M:VDS.RDF.ListExtensions.AssertList``1(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,System.Collections.Generic.IEnumerable{``0},System.Func{``0,VDS.RDF.Nodes.INode})">
            <summary>
            Asserts a list as a RDF collection using an existing node as the list root
            </summary>
            <typeparam name="T">Type of Objects</typeparam>
            <param name="g">Graph to assert in</param>
            <param name="listRoot">Root Node for List</param>
            <param name="objects">Objects to place in the collection</param>
            <param name="mapFunc">Mapping from Object Type to <see cref="T:VDS.RDF.Nodes.INode">INode</see></param>
        </member>
        <member name="M:VDS.RDF.ListExtensions.AssertList(VDS.RDF.Graphs.IGraph,System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Asserts a list as a RDF collection and returns the node that represents the root of the RDF collection
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="objects">Objects to place in the collection</param>
            <returns>
            Either the blank node which is the root of the collection or <strong>rdf:nil</strong> for empty collections
            </returns>
        </member>
        <member name="M:VDS.RDF.ListExtensions.AssertList(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Asserts a list as a RDF collection using an existing node as the list root
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="listRoot">Root Node for List</param>
            <param name="objects">Objects to place in the collection</param>
        </member>
        <member name="M:VDS.RDF.ListExtensions.GetListAsTriples(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Triples that make up a list (aka a RDF collection)
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
            <returns>Triples that make up the List</returns>
        </member>
        <member name="M:VDS.RDF.ListExtensions.GetListItems(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Nodes which are the items of the list (aka the RDF collection)
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
            <returns>Nodes that are the items in the list</returns>
        </member>
        <member name="M:VDS.RDF.ListExtensions.GetListNodes(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Gets all the Nodes which are the intermediate nodes in the list (aka the RDF collection).  These represents the nodes used to link the actual items of the list together rather than the actual items of the list
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
            <returns>Nodes that are the intermediate nodes of the list</returns>
        </member>
        <member name="M:VDS.RDF.ListExtensions.IsListRoot(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Gets whether a given Node is valid as a List Root, this does not guarantee that the list itself is valid simply that the Node appears to be the root of a list
            </summary>
            <param name="n">Node to check</param>
            <param name="g">Graph</param>
            <returns></returns>
            <remarks>
            We consider a node to be a list root if there are no incoming rdf:rest triples and only a single outgoing rdf:first triple
            </remarks>
        </member>
        <member name="M:VDS.RDF.ListExtensions.GetListTail(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Node that represents the last item in the list
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.ListExtensions.RetractList(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode)">
            <summary>
            Retracts a List (aka a RDF collection)
            </summary>
            <param name="g">Graph</param>
            <param name="listRoot">Root Node for List</param>
        </member>
        <member name="M:VDS.RDF.ListExtensions.AddToList``1(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,System.Collections.Generic.IEnumerable{``0},System.Func{``0,VDS.RDF.Nodes.INode})">
            <summary>
            Adds new items to the end of a list (aka a RDF collection)
            </summary>
            <typeparam name="T">Type of Objects</typeparam>
            <param name="g">Graph to assert in</param>
            <param name="listRoot">Root Node for the list</param>
            <param name="objects">Objects to add to the collection</param>
            <param name="mapFunc">Mapping from Object Type to <see cref="T:VDS.RDF.Nodes.INode">INode</see></param>
        </member>
        <member name="M:VDS.RDF.ListExtensions.AddToList(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Adds new items to the end of a list (aka a RDF collection)
            </summary>
            <param name="g">Graph to assert in</param>
            <param name="listRoot">Root Node for the list</param>
            <param name="objects">Objects to add to the collection</param>
        </member>
        <member name="M:VDS.RDF.ListExtensions.RemoveFromList``1(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,System.Collections.Generic.IEnumerable{``0},System.Func{``0,VDS.RDF.Nodes.INode})">
            <summary>
            Removes the given items from a list (aka a RDF collection), if an item occurs multiple times in the list all occurrences will be removed
            </summary>
            <typeparam name="T">Type of Objects</typeparam>
            <param name="g">Graph to retract from</param>
            <param name="listRoot">Root Node for the list</param>
            <param name="objects">Objects to remove from the collection</param>
            <param name="mapFunc">Mapping from Object Type to <see cref="T:VDS.RDF.Nodes.INode">INode</see></param>
        </member>
        <member name="M:VDS.RDF.ListExtensions.RemoveFromList(VDS.RDF.Graphs.IGraph,VDS.RDF.Nodes.INode,System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Removes the given items from a list (aka a RDF collection), if an item occurs multiple times in the list all occurrences will be removed
            </summary>
            <param name="g">Graph to retract from</param>
            <param name="listRoot">Root Node for the list</param>
            <param name="objects">Objects to remove from the collection</param>
        </member>
        <member name="T:VDS.RDF.LiteralExtensions">
            <summary>
            Provides extension methods for converting primitive types into appropriately typed Literal Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Boolean,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Boolean typed literal
            </summary>
            <param name="b">Boolean</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the boolean</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Byte,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Byte typed literal
            </summary>
            <param name="b">Byte</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the byte</returns>
            <remarks>
            Byte in .Net is actually equivalent to Unsigned Byte in XML Schema so depending on the value of the Byte the type will either be xsd:byte if it fits or xsd:usignedByte
            </remarks>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.SByte,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Byte typed literal
            </summary>
            <param name="b">Byte</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the signed bytes</returns>
            <remarks>
            SByte in .Net is directly equivalent to Byte in XML Schema so the type will always be xsd:byte
            </remarks>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTime,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the date time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTime,VDS.RDF.Nodes.INodeFactory,System.Boolean)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
            <returns>Literal representing the date time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTimeOffset,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the date time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.DateTimeOffset,VDS.RDF.Nodes.INodeFactory,System.Boolean)">
            <summary>
            Creates a new Date Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
            <returns>Literal representing the date time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralDate(System.DateTime,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Date typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralDate(System.DateTimeOffset,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Date typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralTime(System.DateTime,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralTime(System.DateTime,VDS.RDF.Nodes.INodeFactory,System.Boolean)">
            <summary>
            Creates a new Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
            <returns>Literal representing the time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.TimeSpan,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new duration typed literal
            </summary>
            <param name="t">Time Span</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the time span</returns>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralTime(System.DateTimeOffset,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteralTime(System.DateTimeOffset,VDS.RDF.Nodes.INodeFactory,System.Boolean)">
            <summary>
            Creates a new Time typed literal
            </summary>
            <param name="dt">Date Time</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <param name="precise">Whether to preserve precisely i.e. include fractional seconds</param>
            <returns>Literal representing the time</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Decimal,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Decimal typed literal
            </summary>
            <param name="d">Decimal</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the decimal</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Double,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Double typed literal
            </summary>
            <param name="d">Double</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the double</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Single,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Float typed literal
            </summary>
            <param name="f">Float</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the float</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int16,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="i">Integer</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the short</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int32,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="i">Integer</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the integer</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.Int64,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new Integer typed literal
            </summary>
            <param name="l">Integer</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the integer</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Factory argument is null</exception>
        </member>
        <member name="M:VDS.RDF.LiteralExtensions.ToLiteral(System.String,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Creates a new String typed literal
            </summary>
            <param name="s">String</param>
            <param name="factory">Node Factory to use for Node creation</param>
            <returns>Literal representing the string</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the Graph/String argument is null</exception>
        </member>
        <member name="T:VDS.RDF.Nodes.ComparisonHelper">
            <summary>
            Static Helper class containing standard implementations of Comparison between various Node types
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.ComparisonHelper.CompareUris(System.Uri,System.Uri)">
            <summary>
            Compares two URIs
            </summary>
            <param name="a">First URI</param>
            <param name="b">Second URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ComparisonHelper.CompareUris(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two URI Nodes
            </summary>
            <param name="a">First URI Node</param>
            <param name="b">Second URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ComparisonHelper.CompareLiterals(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Literal Nodes using global default comparison options where applicable
            </summary>
            <param name="a">First Literal Node</param>
            <param name="b">Second Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ComparisonHelper.CompareLiterals(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
            <summary>
            Compares two Literal Nodes
            </summary>
            <param name="a">First Literal Node</param>
            <param name="b">Second Literal Node</param>
            <param name="culture">Culture to use for lexical string comparisons where more natural comparisons are not possible/applicable</param>
            <param name="comparisonOptions">String Comparison options used for lexical string comparisons where more natural comparisons are not possible/applicable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ComparisonHelper.CompareBlankNodes(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Blank Nodes
            </summary>
            <param name="a">First Blank Node</param>
            <param name="b">Second Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ComparisonHelper.CompareGraphLiterals(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Graph Literals
            </summary>
            <param name="a">First Graph Literal</param>
            <param name="b">Second Graph Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ComparisonHelper.CompareVariables(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Variable Nodes
            </summary>
            <param name="a">First Variable Node</param>
            <param name="b">Second Variable Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.DateNode">
            <summary>
            Valued Node representing a Date value
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.DateTimeNode">
            <summary>
            Valued Node representing a Date Time value
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.LiteralNode">
            <summary>
            Class for representing Literal Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.BaseLiteralNode">
            <summary>
            Abstract Base Class for Literal Nodes
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.BaseNode">
            <summary>
            Abstract Class for Nodes, implements the two basic properties of the INode Interface
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.INode">
            <summary>
            Interface for Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.INode.ToString">
            <summary>
            Gets the String representation of the Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INode.ToString(VDS.RDF.Writing.Formatting.INodeFormatter)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.INode.ToString(VDS.RDF.Writing.Formatting.INodeFormatter,VDS.RDF.Writing.QuadSegment)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.NodeType">
            <summary>
            Nodes have a Type
            </summary>
            <remarks>Primarily provided so can do quick comparison to see what type of Node you have without having to do actual full blown Type comparison</remarks>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.Uri">
            <summary>
            Gets the URI the Node represents if it is a URI node, otherwise produces an error
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a URI node</exception>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.AnonID">
            <summary>
            Gets the ID if it is a blank node, otherwise produces an error
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a blank node</exception>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.Value">
            <summary>
            Gets the Lexical Value if this is a literal node, otherwise produces an error
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a literal node</exception>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.HasLanguage">
            <summary>
            Gets whether the node has a language specifier if this is a literal node, otherwise produces an error
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a literal node</exception>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.HasDataType">
            <summary>
            Gets whether the ode has a data type URI if this is a literal node, otherwise produces an error
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a literal node</exception>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.Language">
            <summary>
            Gets the Language specifier (if any) or null (if none) if this is a literal node, otherwise produces an error 
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a literal node</exception>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.DataType">
            <summary>
            Gets the Data Type URI (if any) or null (if none) if this is a literal node, otherwise produces an error
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a literal node</exception>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.SubGraph">
            <summary>
            Gets the Sub-graph the node represents if this is a graph literal, otherwise produces an error
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a graph literal node</exception>
        </member>
        <member name="P:VDS.RDF.Nodes.INode.VariableName">
            <summary>
            Gets the Variable Name the node represents if this is a variable node, otherwise produces an error
            </summary>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if this is not a variable node</exception>
        </member>
        <member name="F:VDS.RDF.Nodes.BaseNode._hashcode">
            <summary>
            Stores the computed Hash Code for this Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.#ctor(VDS.RDF.Nodes.NodeType)">
            <summary>
            Base Constructor which instantiates the Graph reference, Graph Uri and Node Type of the Node
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="type">Node Type</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.Equals(System.Object)">
            <summary>
            Nodes must implement an Equals method
            </summary>
            <param name="obj">Object to compare against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.ToString">
            <summary>
            Nodes must implement a ToString method
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Essential for the implementation of GetHashCode to work correctly, Nodes should generate a String representation that is 'unique' as far as that is possible.
            </para>
            <para>
            Any two Nodes which match via the Equals method (based on strict RDF Specification Equality) should produce the same String representation since Hash Codes are generated by calling GetHashCode on this String
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.ToString(VDS.RDF.Writing.Formatting.INodeFormatter)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.ToString(VDS.RDF.Writing.Formatting.INodeFormatter,VDS.RDF.Writing.QuadSegment)">
            <summary>
            Gets the String representation of the Node formatted with the given Node formatter
            </summary>
            <param name="formatter">Formatter</param>
            <param name="segment">Triple Segment</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.GetHashCode">
            <summary>
            Gets a Hash Code for a Node
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Implemented by getting the Hash Code of the result of ToString for a Node prefixed with its Node Type, this is pre-computed for efficiency when a Node is created since Nodes are immutable.  See remarks on ToString for more detail.
            </para>
            <para>
            Since Hash Codes are based on a String representation there is no guarantee of uniqueness though the same Node will always give the same Hash Code (on a given Platform - see the MSDN Documentation for <see cref="M:System.String.GetHashCode">string.GetHashCode()</see> for further details)
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.op_Equality(VDS.RDF.Nodes.BaseNode,VDS.RDF.Nodes.BaseNode)">
            <summary>
            The Equality operator is defined for Nodes
            </summary>
            <param name="a">First Node</param>
            <param name="b">Second Node</param>
            <returns>Whether the two Nodes are equal</returns>
            <remarks>Uses the Equals method to evaluate the result</remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.op_Inequality(VDS.RDF.Nodes.BaseNode,VDS.RDF.Nodes.BaseNode)">
            <summary>
            The Non-Equality operator is defined for Nodes
            </summary>
            <param name="a">First Node</param>
            <param name="b">Second Node</param>
            <returns>Whether the two Nodes are non-equal</returns>
            <remarks>Uses the Equals method to evaluate the result</remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.CompareTo(VDS.RDF.Nodes.INode)">
            <summary>
            Nodes must implement a CompareTo method to allow them to be Sorted
            </summary>
            <param name="other">Node to compare self to</param>
            <returns></returns>
            <remarks>
            Implementations should use the SPARQL Term Sort Order for ordering nodes (as opposed to value sort order).  Standard implementations of Node type specific comparisons can be found in <see cref="T:VDS.RDF.Nodes.ComparisonHelper">ComparisonHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.Equals(VDS.RDF.Nodes.INode)">
            <summary>
            Nodes must implement an Equals method so we can do type specific equality
            </summary>
            <param name="other">Node to check for equality</param>
            <returns></returns>
            <remarks>
            Nodes implementations are also required to implement an override of the non-generic Equals method.  Standard implementations of some equality comparisons can be found in <see cref="T:VDS.RDF.Nodes.EqualityHelper">EqualityHelper</see>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the information for serialization
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.GetSchema">
            <summary>
            Gets the schema for XML serialization
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseNode.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseNode.NodeType">
            <summary>
            Nodes have a Type
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.#ctor(System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.#ctor(System.String,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.#ctor(System.String,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.#ctor(System.String,System.Uri)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.#ctor(System.String,System.String,System.Uri,System.Boolean)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">Language specifier for the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.Equals(System.Object)">
            <summary>
            Implementation of the Equals method for Literal Nodes
            </summary>
            <param name="obj">Object to compare the Node with</param>
            <returns></returns>
            <remarks>
            The default behaviour is for Literal Nodes to be considered equal IFF
            <ol>
            <li>Their Language Specifiers are identical (or neither has a Language Specifier)</li>
            <li>Their Data Types are identical (or neither has a Data Type)</li>
            <li>Their String values are identical</li>
            </ol>
            This behaviour can be overridden to use value equality by setting the <see cref="P:VDS.RDF.Options.LiteralEqualityMode">LiteralEqualityMode</see> option to be <see cref="F:VDS.RDF.LiteralEqualityMode.Loose">Loose</see> if this is more suited to your application.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.Equals(VDS.RDF.Nodes.INode)">
            <summary>
            Implementation of the Equals method for Literal Nodes
            </summary>
            <param name="other">Object to compare the Node with</param>
            <returns></returns>
            <remarks>
            The default behaviour is for Literal Nodes to be considered equal IFF
            <ol>
            <li>Their Language Specifiers are identical (or neither has a Language Specifier)</li>
            <li>Their Data Types are identical (or neither has a Data Type)</li>
            <li>Their String values are identical</li>
            </ol>
            This behaviour can be overridden to use value equality by setting the <see cref="P:VDS.RDF.Options.LiteralEqualityMode">LiteralEqualityMode</see> option to be <see cref="F:VDS.RDF.LiteralEqualityMode.Loose">Loose</see> if this is more suited to your application.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.Equals(VDS.RDF.Nodes.BaseLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.ToString">
            <summary>
            Gets a String representation of a Literal Node
            </summary>
            <returns></returns>
            <remarks>Gives a value without quotes (as some syntaxes use) with the Data Type/Language Specifier appended using Notation 3 syntax</remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.CompareTo(VDS.RDF.Nodes.INode)">
            <summary>
            Implementation of CompareTo for Literal Nodes
            </summary>
            <param name="other">Node to Compare To</param>
            <returns></returns>
            <remarks>
            Literal Nodes are greater than Blank Nodes, Uri Nodes and Nulls, they are less than Graph Literal Nodes.
            <br /><br />
            Two Literal Nodes are initially compared based upon Data Type, untyped literals are less than typed literals.  Two untyped literals are compared purely on lexical value, Language Specifier has no effect on the ordering.  This means Literal Nodes are only partially ordered, for example "hello"@en and "hello"@en-us are considered to be the same for ordering purposes though they are different for equality purposes.  Datatyped Literals can only be properly ordered if they are one of a small subset of types (Integers, Booleans, Date Times, Strings and URIs).  If the datatypes for two Literals are non-matching they are ordered on Datatype Uri, this ensures that each range of Literal Nodes is sorted to some degree.  Again this also means that Literals are partially ordered since unknown datatypes will only be sorted based on lexical value and not on actual value.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.CompareTo(VDS.RDF.Nodes.BaseLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the serialization information
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseLiteralNode.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseLiteralNode.Value">
            <summary>
            Gives the lexical value of the literal
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseLiteralNode.HasLanguage">
            <summary>
            Gets whether the literal has a language specifier
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseLiteralNode.Language">
            <summary>
            Gives the language specifier for the literal (if it exists) or null
            </summary>
            <remarks>
            Note that with RDF 1.1 both this and <see cref="P:VDS.RDF.Nodes.BaseLiteralNode.HasDataType"/> may return true, you should always test for this before testing for <see cref="P:VDS.RDF.Nodes.BaseLiteralNode.HasDataType"/>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseLiteralNode.HasDataType">
            <summary>
            Gets whether the literal has a data type URI
            </summary>
            <remarks>
            Note that with RDF 1.1 both this and <see cref="P:VDS.RDF.Nodes.BaseLiteralNode.HasLanguage"/> may return true, you should always test for <see cref="P:VDS.RDF.Nodes.BaseLiteralNode.HasLanguage"/> before testing for this.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseLiteralNode.DataType">
            <summary>
            Gives the data type URI for the literal (if it exists) or null
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.#ctor(System.String)">
            <summary>
            Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.#ctor(System.String,System.String)">
            <summary>
            Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">String value for the Language Specifier for the Literal</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.#ctor(System.String,System.Uri)">
            <summary>
            Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.#ctor(System.String,System.Uri,System.Boolean)">
            <summary>
            Constructor for Literal Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
            <param name="normalize">Whether to Normalize the Literal Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.CompareTo(VDS.RDF.Nodes.LiteralNode)">
            <summary>
            Implementation of Compare To for Literal Nodes
            </summary>
            <param name="other">Literal Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.LiteralNode.Equals(VDS.RDF.Nodes.LiteralNode)">
            <summary>
            Determines whether this Node is equal to a Literal Node
            </summary>
            <param name="other">Literal Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.IValuedNode">
            <summary>
            Interface for Valued Nodes
            </summary>
            <remarks>
            <para>
            This interface extends the basic <see cref="T:VDS.RDF.Nodes.INode">INode</see> interface with methods related to turning the lexical value into a strongly typed .Net value.  It is intended primarily for use within SPARQL expression evaluation where we need to do a lot of value conversions and currently waste a lot of effort (and thus performance) doing that.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsString">
            <summary>
            Gets the String value of the Node
            </summary>
            <returns></returns>
            <remarks>
            This is distinct from <strong>ToString()</strong> because that method will typically include additional information like language specifier/datatype as appropriate whereas this method is used to produce a string as would be produced by applying the <strong>STR()</strong> function from SPARQL
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsInteger">
            <summary>
            Gets the Long value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if the Node cannot be converted to a Long</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsDecimal">
            <summary>
            Gets the Decimal value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if the Node cannot be converted to a Decimal</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsFloat">
            <summary>
            Gets the Float value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if the Node cannot be converted to a Float</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsDouble">
            <summary>
            Gets the Double value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if the Node cannot be converted to a Double</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsBoolean">
            <summary>
            Gets the Boolean value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if the Node cannot be converted to a Boolean</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsDateTime">
            <summary>
            Gets the Date Time value of the Node
            </summary>
            <returns></returns>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if the Node cannot be converted to a Date Time</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsDateTimeOffset">
            <summary>
            Gets the Date Time Offset value of the Node
            </summary>
            <returns></returns>
            <exception cref="!:RdfQueryException">Thrown if the Node cannot be converted to a Date Time Offset</exception>
        </member>
        <member name="M:VDS.RDF.Nodes.IValuedNode.AsTimeSpan">
            <summary>
            Gets the Time Span value of the Node
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.IValuedNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
            <remarks>
            Either String.Empty if no type or the string form of the type URI
            </remarks>
        </member>
        <member name="P:VDS.RDF.Nodes.IValuedNode.NumericType">
            <summary>
            Gets the Numeric Type of the Node
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTimeOffset,System.String,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTime,System.String,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTimeOffset,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTime,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Date Time value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="value">Date Time value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTime)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="value">Date Time value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTimeOffset,System.String)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTime,System.String)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTime,System.DateTimeOffset,System.String)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="value">Date Time value</param>
            <param name="offsetValue">Date Time offset value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.#ctor(System.DateTime,System.DateTimeOffset,System.String,System.Uri)">
            <summary>
            Creates a new Date Time valued node
            </summary>
            <param name="value">Date Time value</param>
            <param name="offsetValue">Date Time offset value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Data Type URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.GetStringForm(System.DateTimeOffset,System.Uri)">
            <summary>
            Gets the String form of the Date Time
            </summary>
            <param name="value">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.GetStringForm(System.DateTime,System.Uri)">
            <summary>
            Gets the String form of the Date Time
            </summary>
            <param name="value">Value</param>
            <param name="datatype">Datatype URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsString">
            <summary>
            Gets the date time value as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsInteger">
            <summary>
            Throws an error as date times cannot be converted to integers
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsDecimal">
            <summary>
            Throws an error as date times cannot be converted to decimals
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsFloat">
            <summary>
            Throws an error as date times cannot be converted to floats
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsDouble">
            <summary>
            Throws an error as date times cannot be converted to doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsBoolean">
            <summary>
            Throws an error as date times cannot be converted to booleans
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsDateTime">
            <summary>
            Gets the date time value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsDateTimeOffset">
            <summary>
            Gets the date time value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DateTimeNode.AsTimeSpan">
            <summary>
            Throws an error as date times cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.DateTimeNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.DateTimeNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.DateNode.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new Date valued node
            </summary>
            <param name="value">Date Time value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateNode.#ctor(System.DateTimeOffset,System.String)">
            <summary>
            Creates a new Date valued node
            </summary>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateNode.#ctor(System.DateTime)">
            <summary>
            Creates a new Date valued node
            </summary>
            <param name="value">Date Time value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DateNode.#ctor(System.DateTime,System.String)">
            <summary>
            Creates a new Date valued node
            </summary>
            <param name="value">Date Time value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="T:VDS.RDF.Nodes.FastNodeComparer">
            <summary>
            A Node Comparer which does faster comparisons since it only does lexical comparisons for literals rather than value comparisons
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.FastNodeComparer.Compare(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Compares two Nodes
            </summary>
            <param name="x">Node</param>
            <param name="y">Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.IBlankNodeGenerator">
            <summary>
            Interface for blank node generators
            </summary>
            <remarks>
            Blank node generators are used to consistently map string identifiers for blank nodes in serialized RDF into blank nodes.  This functionality is generally only required during parsing operations.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.IBlankNodeGenerator.GetGuid(System.String)">
            <summary>
            Create a new blank node ID
            </summary>
            <param name="id">String ID</param>
            <returns>Blank Node ID</returns>
        </member>
        <member name="T:VDS.RDF.Nodes.MappedBlankNodeGenerator">
            <summary>
            A blank node generator that keeps a mapping of string IDs to blank nodes
            </summary>
            <remarks>
            As this implementation keeps a mapping its memory usage will grow over time and for data with large amounts of blank nodes this may exhaust memory
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.MappedBlankNodeGenerator.GetGuid(System.String)">
            <summary>
            Create a new blank node
            </summary>
            <param name="id">String ID</param>
            <returns>Blank Node</returns>
        </member>
        <member name="T:VDS.RDF.Nodes.NodeType">
            <summary>
            Node Type Values
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.NodeType.Blank">
            <summary>
            A Blank Node
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.NodeType.Uri">
            <summary>
            A Uri Node
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.NodeType.Literal">
            <summary>
            A Literal Node
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.NodeType.GraphLiteral">
            <summary>
            A Graph Literal Node
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.NodeType.Variable">
            <summary>
            A Variable Node
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.EffectiveNumericType">
            <summary>
            Effective numeric type for a Node
            </summary>
            <remarks>
            Used to represent what kind of numeric term a node is considered to represent and thus how its value may be retrieved
            </remarks>
        </member>
        <member name="F:VDS.RDF.Nodes.EffectiveNumericType.NaN">
            <summary>
            Not a Number
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.EffectiveNumericType.Integer">
            <summary>
            An Integer
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.EffectiveNumericType.Decimal">
            <summary>
            A Decimal
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.EffectiveNumericType.Float">
            <summary>
            A Single precision Floating Point
            </summary>
        </member>
        <member name="F:VDS.RDF.Nodes.EffectiveNumericType.Double">
            <summary>
            A Double precision Floating Point
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.RandomDerivedBlankNodeGenerator">
            <summary>
            A blank node generator that uses a random number based derivation method to map string IDs to create blank nodes
            </summary>
            <remarks>
            Since this implementation doesn't keep any record of previously generated blank nodes it is extremely memory efficient, however in a few rare cases where two different IDs have colliding hash codes it may generate the same blank node for different IDs.  This can be avoided by using the <see cref="T:VDS.RDF.Nodes.MappedBlankNodeGenerator"/> instead but this implementation is generally preferred because of its low memory usage.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.RandomDerivedBlankNodeGenerator.#ctor">
            <summary>
            Creates a new blank node generator
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.RandomDerivedBlankNodeGenerator.#ctor(System.Int32)">
            <summary>
            Creates a new blank node generator
            </summary>
            <param name="seed">Seed</param>
        </member>
        <member name="M:VDS.RDF.Nodes.RandomDerivedBlankNodeGenerator.DefaultSeed">
            <summary>
            Gets the default seeds which is the current epoch time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.RandomDerivedBlankNodeGenerator.GetGuid(System.String)">
            <summary>
            Create a new blank node
            </summary>
            <param name="id">String ID</param>
            <returns>Blank Node</returns>
        </member>
        <member name="M:VDS.RDF.Nodes.RandomDerivedBlankNodeGenerator.MapToGuid(System.String)">
            <summary>
            Maps a String identifier into a GUID
            </summary>
            <param name="id">ID</param>
            <returns>GUID</returns>
        </member>
        <member name="T:VDS.RDF.Nodes.SignedByteNode">
            <summary>
            Value node representing a signed byte (8-bit signed integer)
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.NumericNode">
            <summary>
            A Valued Node with a numeric value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.#ctor(System.String,System.Uri,VDS.RDF.Nodes.EffectiveNumericType)">
            <summary>
            Creates a new numeric valued node
            </summary>
            <param name="value">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
            <param name="numType">SPARQL Numeric Type</param>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsString">
            <summary>
            Gets the string value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsInteger">
            <summary>
            Gets the integer value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsDecimal">
            <summary>
            Gets the decimal value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsFloat">
            <summary>
            Gets the float value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsDouble">
            <summary>
            Gets the double value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsBoolean">
            <summary>
            Gets the boolean value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsDateTime">
            <summary>
            Throws an error as numerics cannot be converted to date times
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsDateTimeOffset">
            <summary>
            Throws an error as numerics cannot be converted to date times
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NumericNode.AsTimeSpan">
            <summary>
            Throws an error as numerics cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.NumericNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.NumericNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.#ctor(System.SByte,System.String)">
            <summary>
            Creates a new signed byte node
            </summary>
            <param name="value">Signed Byte value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.#ctor(System.SByte)">
            <summary>
            Creates a new signed byte node
            </summary>
            <param name="value">Signed Byte value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.AsInteger">
            <summary>
            Gets the integer value of the signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.AsDecimal">
            <summary>
            Gets the decimal value of the signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.AsFloat">
            <summary>
            Gets the float value of the signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.SignedByteNode.AsDouble">
            <summary>
            Gets the double value of the signed byte
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.TimeSpanNode">
            <summary>
            Valued Node representing a Time Span value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.#ctor(System.TimeSpan)">
            <summary>
            Creates a new Time span node
            </summary>
            <param name="value">Time Span</param>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.#ctor(System.TimeSpan,System.String)">
            <summary>
            Creates a new Time span node 
            </summary>
            <param name="value">Time Span</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.#ctor(System.TimeSpan,System.String,System.Uri)">
            <summary>
            Creates a new Time span node
            </summary>
            <param name="value">Time Span</param>
            <param name="lexicalValue">Lexical value</param>
            <param name="dtUri">Data type URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsString">
            <summary>
            Gets the date time value as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsInteger">
            <summary>
            Throws an error as date times cannot be converted to integers
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsDecimal">
            <summary>
            Throws an error as date times cannot be converted to decimals
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsFloat">
            <summary>
            Throws an error as date times cannot be converted to floats
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsDouble">
            <summary>
            Throws an error as date times cannot be converted to doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsBoolean">
            <summary>
            Throws an error as date times cannot be converted to booleans
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsDateTime">
            <summary>
            Gets the date time value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsDateTimeOffset">
            <summary>
            Gets the date time value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.TimeSpanNode.AsTimeSpan">
            <summary>
            Gets the time span value of the node
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.TimeSpanNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.TimeSpanNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.GraphCollection">
            <summary>
            Basic implementation of a Graph Collection
            </summary>
        </member>
        <member name="F:VDS.RDF.Collections.GraphCollection._graphs">
            <summary>
            Dictionary of Graph names to Graphs
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.GraphCollection.#ctor">
            <summary>
            Creates a new Graph Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.GraphCollection.ContainsKey(VDS.RDF.Nodes.INode)">
            <summary>
            Checks whether the Graph with the given Uri exists in this Graph Collection
            </summary>
            <param name="graphName">Graph name to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.GraphCollection.Add(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Adds a Graph to the Collection
            </summary>
            <param name="graphName">Graph to add to</param>
            <param name="g">Graph to add</param>
        </member>
        <member name="M:VDS.RDF.Collections.GraphCollection.Remove(VDS.RDF.Nodes.INode)">
            <summary>
            Removes a Graph from the Collection
            </summary>
            <param name="graphName">Name of the Graph to remove</param>
        </member>
        <member name="M:VDS.RDF.Collections.GraphCollection.Clear">
            <summary>
            Clears the graphs from the collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.GraphCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.GraphCollection.Dispose">
            <summary>
            Disposes of the Graph Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.GraphCollection.Count">
            <summary>
            Gets the number of Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.GraphCollection.Keys">
            <summary>
            Provides access to the names of the Graphs in the Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.GraphCollection.Values">
            <summary>
            Gets the graphs in the collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.GraphCollection.Item(VDS.RDF.Nodes.INode)">
            <summary>
            Gets a Graph from the Collection
            </summary>
            <param name="graphName">Graph name</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.UnsignedLongNode">
            <summary>
            A Valued Node with a unsigned long value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.#ctor(System.UInt64,System.String)">
            <summary>
            Creates a new unsigned long valued node
            </summary>
            <param name="value">Unsigned Long value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.#ctor(System.UInt64,System.String,System.Uri)">
            <summary>
            Creates a new unsigned long valued node
            </summary>
            <param name="value">Unsigned Long value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.#ctor(System.UInt64)">
            <summary>
            Creates a new usigned long valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Unsigned Long value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.AsInteger">
            <summary>
            Gets the long value of the ulong
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.AsDecimal">
            <summary>
            Gets the decimal value of the ulong
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.AsFloat">
            <summary>
            Gets the float value of the ulong
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.UnsignedLongNode.AsDouble">
            <summary>
            Gets the double value of the ulong
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.UriComparer">
            <summary>
            Equality comparer that compares URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.UriComparer.Compare(System.Uri,System.Uri)">
            <summary>
            Compares two URIs
            </summary>
            <param name="x">URI</param>
            <param name="y">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.UriComparer.Equals(System.Uri,System.Uri)">
            <summary>
            Determines whether two URIs are equal
            </summary>
            <param name="x">URI</param>
            <param name="y">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.UriComparer.GetHashCode(System.Uri)">
            <summary>
            Gets the Hash Code for a URI
            </summary>
            <param name="obj">URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.NamespaceDoc">
            <summary>
            <para>
            Top Level Namespace for the <strong>dotNetRDF Library</strong> which embodies a simple but powerful API for working with RDF and SPARQL.   
            </para>
            <para>
            Specific Namespaces within the Hierarchy provide <see cref="N:VDS.RDF.Parsing">Parsing</see> and <see cref="N:VDS.RDF.Writing">Serialization</see> functionality along with a host of related classes to support these functions.
            </para>
            <para>
            Support for querying RDF is provided in the <see cref="N:VDS.RDF.Query">Query</see> namespace which includes SPARQL Query, limited reasoning support in the <see cref="N:VDS.RDF.Query.Inference">Query.Inference</see> namespace and a Pellet Server client in the <see cref="N:VDS.RDF.Query.Inference.Pellet">Query.Inference.Pellet</see> namespace.
            </para>
            <para>
            Support for updating RDF based on the SPARQL 1.1 Update and Graph Store HTTP Protocol for RDF Graph Management is provided in the <see cref="N:VDS.RDF.Update">Update</see> and <see cref="N:VDS.RDF.Update.Protocol">Update.Protocol</see> namespaces.
            </para>
            <h3>Third Party Storage</h3>
            <para>For communicating with arbitrary Triple Stores we have a dedicated <see cref="N:VDS.RDF.Storage">Storage</see> namespace.  As of this release we support the following Triple Stores:
            <ul>
                <li>AllegroGraph</li>
                <li>Dydra</li>
                <li>4store</li>
                <li>Fuseki</li>
                <li>Any Sesame HTTP Protocol compliant store e.g. Sesame, OWLIM</li>
                <li>Any SPARQL Graph Store HTTP Protocol for RDF Graph Management compliant stores</li>
                <li>Any SPARQL store that exposes a Query and/or Update endpoint</li>
                <li>Stardog</li>
                <li>Virtuoso</li>
            </ul>
            </para>
            <h3>ASP.Net Integration</h3>
            <para>
            For those building ASP.Net based websites the <see cref="N:VDS.RDF.Web">Web</see> namespace is dedicated to providing classes for integrating RDF into ASP.Net applications.
            </para>
            <h3>Ontology API</h3>
            <para>
            There is also an <see cref="N:VDS.RDF.Ontology">Ontology</see> namespace which provides a more resource and ontology centric API for working with RDF than the standard Graph and Triple centric APIs
            </para>
            <h3>Configuration API</h3>
            <para>
            We provide a <see cref="N:VDS.RDF.Configuration">Configuration</see> API which provides for encoding configuration in RDF Graphs.  This configuration system is used extensively as part of the ASP.Net support as it allows for much more expressive and flexible configurations than were previously possible.  See the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">documentation</a> on the main website for many detailed examples.  This is primarily intended as an easy way to help deploy configurations for ASP.Net applications though you can make use of the API to describe the configuration of various types of objects in other applications, for example we use it in our Store Manager utility to store connection details.
            </para>
            <h3>Notes</h3>
            <para>
            dotNetRDF 1.0.0 is now considered a stable release, this means it should be stable for production scenarios.  However it is open source software and despite our best efforts there may still be bugs.  Please help us improve this library by emailing us when you find a bug, you can use the <a href="mailto:dotnetrdf-bugs@lists.sourceforge.net">Bug Reports list</a> to report bugs, the <a href="mailto:dotnetrdf-support@lists.sourceforge.net">Support list</a> to ask questions and the <a href="mailto:dotnetrdf-develop@lists.sourceforge.net">Developer list</a> to request new features or discuss development plans (all these are SourceForge mailing lists which require subscription).
            </para>
            <h4>Alternative Builds</h4>
            <h5>Mono Build</h5>
            <para>
            There is no separate build for Mono since dotNetRDF can run directly under Mono.  Note that there may still be some features of .Net we use that Mono does not fully support, see the <a href="http://www.dotnetrdf.org/content.asp?pageID=Mono%20Issues">Mono Issues</a> page for more details.  We recommend Mono 2.10 or higher though the library should run on recent 2.6/2.8 releases.
            </para>
            <h5>Client Profile Build</h5>
            <para>
            The Client Profile build omits the reference to <see cref="N:System.Web">System.Web</see> so lacks the ASP.Net integration and some other features that rely on this dependency but is otherwise a fairly complete build of the library.
            </para>
            <h5>Silverlight/Windows Phone 7 Build</h5>
            <para>
            The Silverlight and Windows Phone 7 builds of dotNetRDF (<em>dotNetRDF.Silverlight.dll</em> and <em>dotNetRDF.WindowsPhone.dll</em>) are experimental builds that receive limited internal testing so please be aware that these are not as stable as the standard .Net builds.  These build runs on Silverlight 4/Windows Phone 7 and omits the following features since they can't be supported on these platforms:
            </para>
            <ul>
                <li>Most of the <see cref="N:VDS.RDF.Web">Web</see> namespaces</li>
                <li>Does not include parts of the <see cref="N:VDS.RDF.Storage">Storage</see> namespace that would require synchronous HTTP</li>
                <li>No String normalization support</li>
                <li>No <see cref="!:VDS.RDF.Parsing.UriLoader">UriLoader</see> caching support</li>
                <li>No multi-threaded support where <see cref="!:System.Threading.ReaderWriteLockSlim">ReaderWriterLockSlim</see> is used</li>
                <li>Various writers and parsers use streaming rather than DOM based XML parsing</li>
                <li>No support for XSL in TriX files</li>
                <li>Synchronous HTTP Request Features - For most of these there are asynchronous callback driven versions of these features available from the 0.5.0 release onwards</li>
            </ul>
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration Classes which are used for dynamic loading of Configuration serialized as RDF Graphs.
            </para>
            <para>
            This API which provides for encoding dotNetRDF centric configuration in RDF Graphs though it can be extended to serialize and deserialize arbitrary objects if desired.  This configuration API is used extensively with our ASP.Net support as it allows for highly expressive and flexible configurations.  See the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">documentation</a> on the main website for many detailed examples.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Configuration.Permissions.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes related to configuring Permissions
            </para>
            <para>
            <strong>Warning:</strong> The API here is experimental and may changed/be removed in future releases
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.NamespaceDoc">
            <summary>
            Namespace for specialised node implementations and the <see cref="T:VDS.RDF.Nodes.IValuedNode"/> interface, this is an extension of the <see cref="T:VDS.RDF.Nodes.INode"/> interface that provides strongly typed access to the value of a node.
            <para>
            These implementations are primarily used internally in the SPARQL engine, however as these all derive from the standard <see cref="T:VDS.RDF.Nodes.INode"/> implementations they can be used interchangeably with those if desired.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Ontology.NamespaceDoc">
            <summary>
            <para>
            The Ontology Namespace is based upon <a href="http://jena.sourceforge.net/ontology/">Jena's Ontology API</a>.  It allows for a more ontology-centric way of manipulating RDF graphs within the dotNetRDF API.
            </para>
            <para>
            The <see cref="!:OntologyResource">OntologyResource</see> is the base class of resources and allows for the retrieval and manipulation of various common properties of a resource.  More specialised classes like <see cref="!:OntologyClass">OntologyClass</see> and <see cref="!:OntologyProperty">OntologyProperty</see> are used to work with classes and properties etc.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.NamespaceDoc">
            <summary>
            <para>
            Namespace for Parsing classes and variety of supporting Classes.
            </para>
            <para>
            Classes here are primarily implementations of <see cref="!:IRdfReader">IRdfReader</see> with some implementations of <see cref="!:IStoreReader">IStoreReader</see> and a few other specialised classes.
            </para>
            <para>
            Has child namespaces <see cref="N:VDS.RDF.Parsing.Events">Events</see> and <see cref="N:VDS.RDF.Parsing.Tokens">Tokens</see> for supporting Event and Token based Parsing.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Contexts.NamespaceDoc">
            <summary>
            <para>
            Namespace for Parser Context classes, these are classes that are used internally by parsers to store their state.  This allows parsers to be safely used in a multi-threaded scenario so the parsing of one Graph/Store cannot affect the parsing of another.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Events.NamespaceDoc">
            <summary>
            Namespace for Event classes which are used to support Event Based parsing of RDF syntaxes
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Handlers.NamespaceDoc">
            <summary>
            <para>
            Namespace for RDF and SPARQL Results Handlers
            </para>
            <para>
            Handlers are a powerful low level part of the parsers API, they allow you to parse RDF, RDF Datasets and SPARQL Results in such a way that you can take arbitrary actions with the data and choose to end parsing as soon as desired.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Tokens.NamespaceDoc">
            <summary>
            <para>
            Namespace for Token classes which are used to support Token Based parsing of RDF syntaxes
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Parsing.Validation.NamespaceDoc">
            <summary>
            <para>
            Namespace for Validator classes that can be used to validate various forms of syntax
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.NamespaceDoc">
            <summary>
            <para>
            Namespace for Query Classes which provide querying capabilities on RDF.
            </para>
            <para>
            Query capabilities are centered around support for the SPARQL standard.  You can execute full SPARQL 1.1 queries over in-memory data or submit queries to remote SPARQL endpoints.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.NamespaceDoc">
            <summary>
            <para>
            Namespace for Aggregate classes which implement Aggregate functions for SPARQL
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Leviathan.NamespaceDoc">
            <summary>
            Namespace for aggregates provided by the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.Sparql.NamespaceDoc">
            <summary>
            Namespace for the built-in SPARQL aggregates
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Aggregates.XPath.NamespaceDoc">
            <summary>
            Namespace for aggregates provided by the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Algebra.NamespaceDoc">
            <summary>
            <para>
            Contains the classes which model the mapping of SPARQL queries into the SPARQL Algebra.  This namespace is a key component of the new <strong>Leviathan</strong> SPARQL engine introduced in the 0.2.x builds of dotNetRDF
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Construct.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes used in executing CONSTRUCT queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Datasets.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes used to define a Dataset over which SPARQL Queries and Updates evaluated using the Leviathan engine operate
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Describe.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes which implement algorithms for executing DESCRIBE queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.NamespaceDoc">
            <summary>
            <para>
            Namespace containing all the classes related to the execution of expressions in SPARQL queries.  Any valid expression should be able to be modelled and executed using these clases.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Arithmetic.NamespaceDoc">
            <summary>
            Namespace containing expression classes pertaining to arithmetic operations
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Comparison.NamespaceDoc">
            <summary>
            Namespace containing expression classes pertaining to comparison operations
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Conditional.NamespaceDoc">
            <summary>
            Namespace containing expression classes pertaining to conditional operations
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.NamespaceDoc">
            <summary>
            <para>
            Namespace containing expression classes which model functions in SPARQL expressions
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Arq.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the ARQ function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Hash.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the hash functions from the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the numeric functions from the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Leviathan.Numeric.Trigonometry.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the trigonometric functions from the Leviathan function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Boolean.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions which have boolean results
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Constructor.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions which construct new terms
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.DateTime.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions pertaining to date times
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Hash.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions pertaining to hash algorithms
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Numeric.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in numeric functions
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.Set.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions pertaining to sets (IN and NOT IN)
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.Sparql.String.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide the SPARQL built-in functions pertaining to string manipulation
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Cast.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide cast functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.DateTime.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide date time functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.Numeric.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide numeric functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Functions.XPath.String.NamespaceDoc">
            <summary>
            Namespace containing expression classes which provide string functions from the XPath function library
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Expressions.Primary.NamespaceDoc">
            <summary>
            Namespace containing expression classes representing primary constructs in SPARQL expression trees i.e. constants, modifiers and variables
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Filters.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes pertaining to the filtering of the results of SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Grouping.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes used to apply GROUP BY clauses to SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.NamespaceDoc">
            <summary>
            <para>
            Namespace for Inference Classes which provide Inferencing capabilities on RDF - these features are currently experimental and may not work as expected.
            </para>
            <para>
            Classes which implement reasoning must implement the <see cref="!:IInferenceEngine">IInferenceEngine</see> interface, these can then be attached to classes which implement the <see cref="!:IInferencingTripleStore">IInferencingTripleStore</see> interface or they can be used to apply inference to any <see cref="!:IGraph">IGraph</see> implementation with the inferred Triples optionally output to a separate Graph.
            </para>
            <para>
            OWL reasoning currently has extremely limited support, we provide a Pellet client in the <see cref="N:VDS.RDF.Query.Inference.Pellet">Pellet</see> namespace which can be used to connect to a Pellet Server but that currently only provides reasoning on external knowledge bases on the Pellet Server
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides a client for interacting with a Pellet Server
            </para>
            <para>
            Due to Pellet Server being a relatively new product it is currently only possible to reason over external knowledge bases on a Pellet Server and not to use Pellet to reason over in-memory data.  As Pellet Server is updated in the future this client will be updated to take advantage of those updates and to eventually provide for in-memory reasoning.  You may also want to consider using the <see cref="!:VDS.RDF.Storage.StardogConnector"/> which is the triple store from the same people who developed Pellet and which integrates some Pellet capabilities.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Inference.Pellet.Services.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides classes which represent the Services offered by a Pellet Server knowledge base
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides classes which represent the implementation of various operators in SPARQL.  This allows for some of the basic operators like + and - to be extended to allow functionality beyond the SPARQL specification such as date time arithmetic.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.DateTime.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides implementations of <see cref="!:ISparqlOperator"/> which allow for embedding date time arithmetic into SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Operators.Numeric.NamespaceDoc">
            <summary>
            <para>
            Namespace which provides implementations of <see cref="!:ISparqlOperator"/> which provide the default numeric implementations of operators as required by the SPARQL specification
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Optimisation.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes that are used in the Optimisation of SPARQL Queries.  Includes the interfaces <see cref="!:IQueryOptimiser">IQueryOptimiser</see> and <see cref="!:IAlgebraOptimiser">IAlgebraOptimiser</see> which can be used to implement custom query optimisation. 
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Ordering.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes used to order the results of SPARQL queries
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Paths.NamespaceDoc">
            <summary>
            <para>
            Contains the classes which model property paths in SPARQL, they can be used to both represent and evaluate a property path as part of a SPARQL query.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.Patterns.NamespaceDoc">
            <summary>
            Namespace for Pattern Classes that are used in the Graph and Triple matching process for executing SPARQL queries on <see cref="!:IInMemoryQueryableStore">IInMemoryQueryableStore</see> objects
            </summary>
        </member>
        <member name="T:VDS.RDF.Query.PropertyFunctions.NamespaceDoc">
            <summary>
            Namespace which provide classes relating to the property function extension point of SPARQL
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.NamespaceDoc">
            <summary>
            <para>
            Namespace for ctorage classes which provide support for using arbitrary backing Stores
            </para>
            <para>
            Storage is managed via the <see cref="!:IStorageProvider">IStorageProvider</see> interface, see the <a href="http://www.dotnetrdf.org/content.asp?pageID=Triple%20Store%20Integration">Triple Store Integration</a> documentation on the main website for more detail.
            </para>
            <h3>Data Provider Libraries</h3>
            <para>
            From the 0.5.0 release onwards any triple store integration that requires additional dependencies are provided with their own library to reduce dependencies in the Core library and allow that functionality to be optional.  The following stores are currently provided in separate libraries:
            </para>
            <ul>
                <li>Virtuoso - Virtuoso support can be found in the <strong>dotNetRDF.Data.Virtuoso.dll</strong> library and requires one additional dependency.</li>
            </ul>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.NamespaceDoc">
            <summary>
            <para>
            Namespace for storage classes which provide support for managing servers that provide multiple backing Stores
            </para>
            <para>
            Servers are managed via the <see cref="!:IStorageServer"/> interface, a server can provide lists of available stores, retrieve a reference to a store, create new stores and delete existing stores.  The exact capabilites may depend on the implementation and may be inspected via the <see cref="!:IStorageServer.IOBehaviour"/> property.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.NamespaceDoc">
            <summary>
            <para>
            Namespace for storage classes which provide support for creating new stores in conjunction with a <see cref="!:IStorageServer"/>
            </para>
            <para>
            In order for an <see cref="!:IStorageServer"/> to create a new store it requires an instance of the <see cref="!:IStoreTemplate"/> interface from this namespace.  The basic interface provides only a Store ID, specific implementations may provide many more customizable properties to allow new stores to be created that take advantage of the capabilties of the server the store is being created on.  A <see cref="!:IStorageServer"/> provides methods to generate the basic templates that it accepts and should be used in preference to creating any of the implementations directly.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Sesame.NamespaceDoc">
            <summary>
            <para>
            Namespace containing implementations of <see cref="!:IStoreTemplate"/> which provide templates for creating new stores on Sesame servers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Storage.Management.Provisioning.Stardog.NamespaceDoc">
            <summary>
            <para>
            Namespace containing implementations of <see cref="!:IStoreTemplate"/> which provide templates for creating new stores on Stardog servers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.NamespaceDoc">
            <summary>
            <para>
            Namespace for performing updates on Triple Stores using SPARQL Update
            </para>
            <para>
            This is a new part of the API introduced in the 0.3.0 release and adds support for using SPARQL to update Triple Stores.  SPARQL Update is part of the new SPARQL 1.1 standard and provides syntax for inserting, modifying and deleting data as well as managing graphs in a store.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Commands.NamespaceDoc">
            <summary>
            <para>
            Namespace containing classes which model SPARQL Update Commands.  These can be used both to represent SPARQL Updates and to execute them over in-memory stores.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Update.Protocol.NamespaceDoc">
            <summary>
            <para>
            Namespaces containing classes which implement the SPARQL Graph Store HTTP Protocol for RDF Graph Management
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.NamespaceDoc">
            <summary>
            <para>
            Namespace for Classes designed to aid the deployment of Linked Data, SPARQL Endpoints and other Semantic Web technologies as part of ASP.Net web applications.
            </para>
            <para>
            The ASP.Net support leverages the <see cref="N:VDS.RDF.Configuration">Configuration API</see> heavily and so only requires only 1 &lt;appSetting&gt; like so:
            <code>
            &lt;add key="dotNetRDFConfig" value="~/App_Data/config.ttl" /&gt;
            </code>
            This setting provides a pointer to an RDF configuration graph that uses the <a href="http://www.dotnetrdf.org/configuration#">Configuration Vocabulary</a> to express the configuration of HTTP Handlers for your ASP.Net application.  We also now provide a command line tool <a href="http://www.dotnetrdf.org/content.asp?pageID=rdfWedDeploy">rdfWebDeploy</a> which can be used to automate the testing and deployment of this configuration.  See documentation on the <a href="http://www.dotnetrdf.org/content.asp?pageID=Configuration%20API">Configuration API</a> for more detail.  Individual handler documentation gives basic examples of Handler configurations.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for HTTP Handlers provided as part of the <strong>Web</strong> namespace.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Protocol.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for SPARQL Graph Store HTTP Protocol
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Query.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for SPARQL Query handlers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Resource.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for handlers which serve resources such as Graphs
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Server.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for SPARQL Servers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Web.Configuration.Update.NamespaceDoc">
            <summary>
            <para>
            Namespace for Configuration classes which are used to load and store the configuration settings for SPARQL Update handlers
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.NamespaceDoc">
            <summary>
            <para>
            Namespace for Writing Classes which provide the means to Serialize RDF Graphs as concrete RDF syntaxes or graphical representations.
            </para>
            <para>
            Also contains classes that can be used to save Graphs and Triple Stores to arbitrary database backed storage using classes from the <see cref="N:VDS.RDF.Storage">Storage</see> namespace.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Contexts.NamespaceDoc">
            <summary>
            <para>
            Namespace for Writer Context classes, these are classes that are used internally by writers to store their state.  This allows writers to be safely used in a multi-threaded scenario since the writing of one Graph/Store cannot affect the writing of another.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.NamespaceDoc">
            <summary>
            <para>
            Namespace for Formatter Classes which can be used to format <see cref="!:VDS.RDF.Triple">Triples</see>, <see cref="!:VDS.RDF.INode">Nodes</see> and <see cref="T:System.Uri">URIs</see> among other types.
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Serialization.NamespaceDoc">
            <summary>
            <para>
            Namespace for classes related to .Net serialization integration in the library
            </para>
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.TripleCollection">
            <summary>
            Basic Triple Collection which is not indexed
            </summary>
        </member>
        <member name="F:VDS.RDF.Collections.TripleCollection._triples">
            <summary>
            Underlying Storage of the Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Collections.TripleCollection.Contains(VDS.RDF.Graphs.Triple)">
            <summary>
            Determines whether a given Triple is in the Triple Collection
            </summary>
            <param name="t">The Triple to test</param>
            <returns>True if the Triple already exists in the Triple Collection</returns>
        </member>
        <member name="M:VDS.RDF.Collections.TripleCollection.Add(VDS.RDF.Graphs.Triple)">
            <summary>
            Adds a Triple to the Collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.Collections.TripleCollection.Remove(VDS.RDF.Graphs.Triple)">
            <summary>
            Deletes a Triple from the Colleciton
            </summary>
            <param name="t">Triple to remove</param>
            <remarks>Deleting something that doesn't exist has no effect and gives no error</remarks>
        </member>
        <member name="M:VDS.RDF.Collections.TripleCollection.GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TripleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the Enumerator for the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.TripleCollection.Dispose">
            <summary>
            Disposes of a Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.TripleCollection.Count">
            <summary>
            Gets the Number of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.TripleCollection.SubjectNodes">
            <summary>
            Gets all the Nodes which are Subjects of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.TripleCollection.PredicateNodes">
            <summary>
            Gets all the Nodes which are Predicates of Triples in the Triple Collection
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.TripleCollection.ObjectNodes">
            <summary>
            Gets all the Nodes which are Objects of Triples in the Triple Collectio
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.QuadSegment">
            <summary>
            Indicates which segment of a Quad that node output is being generated for
            </summary>
            <remarks>
            Used by Writers and Formatters to ensure restrictions on which Nodes can appear where in the syntax are enforced
            </remarks>
        </member>
        <member name="F:VDS.RDF.Writing.QuadSegment.Subject">
            <summary>
            Subject
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.QuadSegment.Predicate">
            <summary>
            Predicate
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.QuadSegment.Object">
            <summary>
            Object
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.QuadSegment.Graph">
            <summary>
            Graph name
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.WriterErrorMessages">
            <summary>
            Class containing constants for standardised Writer Error Messages
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralsUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Graph Literals
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.UnknownNodeTypeUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Unknown Node Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.LiteralSubjectsUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Literal Subjects
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.LiteralPredicatesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Literal Predicates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.LiteralGraphNamesUnserializableError">
            <summary>
            Error message produces when a User attempts to serialize a Quad which has a Literal Graph name
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralPredicatesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialized a Graph containing Triples with Graph Literal Predicates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.BlankPredicatesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing Triples with Blank Node Predicates
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.UnreducablePropertyUriUnserializable">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing URIs which cannot be reduced to a URIRef or QName as required by the serialization
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.MalformedCollectionWithMultipleFirsts">
            <summary>
            Error message produced when a User attempts to serialize a Graph containing collections where a collection item has more than one rdf:first triple
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.ThreadedOutputError">
            <summary>
            Error messages produced when errors occur in a multi-threaded writing process
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterErrorMessages.VariableNodesUnserializableError">
            <summary>
            Error message produced when a User attempts to serialize a Variable Node in a format which does not support it
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralsUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Graph Literals are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.UnknownNodeTypeUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Unknown Node Types are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.VariableNodesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Variable Nodes are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.LiteralGraphNamesUnserializable(System.String)">
            <summary>
            Gets an error message indicating that literal graph names are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.LiteralSubjectsUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Literal Subjects are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.LiteralPredicatesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Literal Predicates are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.GraphLiteralPredicatesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Graph Literal Predicates are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.BlankPredicatesUnserializable(System.String)">
            <summary>
            Gets an Error message indicating that Blank Node Predicates are not serializable with the appropriate RDF format name inserted in the error
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterErrorMessages.ThreadedOutputFailure(System.String)">
            <summary>
            Gets an Error message indicating that a multi-threading writer process failed
            </summary>
            <param name="format">RDF format (syntax)</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.GraphCallback">
            <summary>
            Callback for methods that return a <see cref="T:VDS.RDF.Graphs.IGraph">IGraph</see> asynchronously
            </summary>
            <param name="g">Graph</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.GraphStoreCallback">
            <summary>
            Callback for methods that return a <see cref="T:VDS.RDF.Graphs.IGraphStore"/> asynchronously
            </summary>
            <param name="graphStore">Graph store</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.NamespaceCallback">
            <summary>
            Callback for methods that return a Namespace Map
            </summary>
            <param name="nsmap">Namespace Map</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.NodeListCallback">
            <summary>
            Callbacks for methods that return a list of nodes
            </summary>
            <param name="nodes">Node List</param>
            <param name="state">State</param>
            <remarks>
            In the event of an error you will be passed an instance of <see cref="T:VDS.RDF.AsyncError"/> which will contain the error and the original state information you passed into the method that took this callback
            </remarks>
        </member>
        <member name="T:VDS.RDF.AsyncError">
            <summary>
            Marker that will be passed to your callback in the event that an async error occurs, provides access to the error and any state that you passed in originally
            </summary>
        </member>
        <member name="M:VDS.RDF.AsyncError.#ctor(System.Exception,System.Object)">
            <summary>
            Creates new async error
            </summary>
            <param name="ex">Exception</param>
            <param name="state">State</param>
        </member>
        <member name="P:VDS.RDF.AsyncError.Error">
            <summary>
            Gets the error that occurred
            </summary>
        </member>
        <member name="P:VDS.RDF.AsyncError.State">
            <summary>
            Gets the original state that was passed in to the async call
            </summary>
        </member>
        <member name="T:VDS.RDF.Collections.UnionTripleCollection">
            <summary>
            Represents a union of multiple Triple Collections
            </summary>
            <remarks>
            <para>
            The union consists of a <em>Base</em> collection which is the collection that Triples can actually be added to and deleted from and any number of additional collections which are read-only as far as the union is concerned (this does not mean they cannot be altered elsewhere by other code)
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.UnionTripleCollection.#ctor(VDS.RDF.Collections.BaseTripleCollection,VDS.RDF.Collections.BaseTripleCollection)">
            <summary>
            Creates a new Union Triple Collection which is a union of two collections
            </summary>
            <param name="baseTriples">Base Triple Collection</param>
            <param name="additionalTriples">Additional Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.Collections.UnionTripleCollection.#ctor(VDS.RDF.Collections.BaseTripleCollection,System.Collections.Generic.IEnumerable{VDS.RDF.Collections.BaseTripleCollection})">
            <summary>
            Creates a new Union Triple Collection which is a union of any number of collections
            </summary>
            <param name="baseTriples">Base Triple Collection</param>
            <param name="additionalTriples">Additional Triple Collection(s)</param>
        </member>
        <member name="M:VDS.RDF.Collections.UnionTripleCollection.Add(VDS.RDF.Graphs.Triple)">
            <summary>
            Adds a Triple to the base collection
            </summary>
            <param name="t">Triple to add</param>
        </member>
        <member name="M:VDS.RDF.Collections.UnionTripleCollection.Contains(VDS.RDF.Graphs.Triple)">
            <summary>
            Checks whether the union contains this Triple in any of the collections it comprises
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Collections.UnionTripleCollection.Remove(VDS.RDF.Graphs.Triple)">
            <summary>
            Removes a Triple from the base collection
            </summary>
            <param name="t">Triple to remove</param>
        </member>
        <member name="M:VDS.RDF.Collections.UnionTripleCollection.Dispose">
            <summary>
            Disposes of the collection
            </summary>
            <remarks>
            This does nothing since we don't know where and how the collections we are the union of are being used and therefore to dispose of them could have unwanted/unexpected results
            </remarks>
        </member>
        <member name="M:VDS.RDF.Collections.UnionTripleCollection.GetEnumerator">
            <summary>
            Gets the enumeration of Triples in the union
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Collections.UnionTripleCollection.Count">
            <summary>
            Gets the count of Triples in this union
            </summary>
            <remarks>
            The Count is the total number of Triples, this may be different from the number of distinct triples
            </remarks>
        </member>
        <member name="P:VDS.RDF.Collections.UnionTripleCollection.ObjectNodes">
            <summary>
            Gets the enumeration of distinct objects of Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.UnionTripleCollection.PredicateNodes">
            <summary>
            Gets the enumeration of distinct predicates of Triples
            </summary>
        </member>
        <member name="P:VDS.RDF.Collections.UnionTripleCollection.SubjectNodes">
            <summary>
            Gets the enumeration of distinct subjects of Triples
            </summary>
        </member>
        <member name="T:VDS.RDF.RdfReaderWarning">
            <summary>
            Delegate Type for Warning Messages raised by RDF Readers
            </summary>
            <param name="warning">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.RdfWriterWarning">
            <summary>
            Delegate Type for Warning Messages raised by RDF Writers
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.SparqlWarning">
            <summary>
            Delegate Type for Warning Events raised by SPARQL Readers and Writers for Queries, Updates and Results
            </summary>
            <param name="message">Warning Message</param>
        </member>
        <member name="T:VDS.RDF.TripleIndexType">
            <summary>
            Possible Triple Index types
            </summary>
            <remarks>
            <para>
            Index types are given Integer values with the lowest being the least useful index and the highest being most useful index.  Non-Index based Patterns are given arbitrary high values since these will typically never be used as these items are usually inserted into a Graph Pattern after the ordering step
            </para>
            <para>
            When used to sort Patterns as part of query optimisation the patterns are partially ordered on the usefullness of their index since more useful indexes are considered more likely to return fewer results which will help restrict the query space earlier in the execution process.
            </para>
            </remarks>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.NoVariables">
            <summary>
            No Index should be used as the Pattern does not use Variables
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.None">
            <summary>
            No Index should be used as the Pattern is three Variables
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Subject">
            <summary>
            Subject Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Predicate">
            <summary>
            Predicate Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.Object">
            <summary>
            Object Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SubjectPredicate">
            <summary>
            Subject-Predicate Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.PredicateObject">
            <summary>
            Predicate-Object Index should be used
            </summary>
        </member>
        <member name="F:VDS.RDF.TripleIndexType.SubjectObject">
            <summary>
            Subject-Object Index should be used
            </summary>
        </member>
        <member name="T:VDS.RDF.TripleIndexSorter">
            <summary>
            A Comparer which sorts based on Triple Index Type
            </summary>
        </member>
        <member name="M:VDS.RDF.TripleIndexSorter.Compare(VDS.RDF.TripleIndexType,VDS.RDF.TripleIndexType)">
            <summary>
            Compares two Triple Index types to see which is greater
            </summary>
            <param name="x">First Index type</param>
            <param name="y">Second Index type</param>
            <returns></returns>
            <remarks>
            Implemented by converting to Integers and then using the Integer comparison function
            </remarks>
        </member>
        <member name="T:VDS.RDF.IndexHelper">
            <summary>
            Helper Class for indexing related operations
            </summary>
        </member>
        <member name="M:VDS.RDF.IndexHelper.SearchIndex``1(System.Collections.Generic.List{``0},System.Collections.Generic.IComparer{``0},``0)">
            <summary>
            Searches an Index using the given Comparer
            </summary>
            <typeparam name="T">Indexed Object Type</typeparam>
            <param name="index">Index</param>
            <param name="comparer">Comparer to use for binary search</param>
            <param name="search">Item to search for</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.BooleanNode">
            <summary>
            Valued Node representing boolean values
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.#ctor(System.Boolean,System.String)">
            <summary>
            Creates a new boolean valued node
            </summary>
            <param name="g">Graph the node belong to</param>
            <param name="value">Boolean Value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.#ctor(System.Boolean)">
            <summary>
            Creates a new boolean valued node
            </summary>
            <param name="g">Graph the node belongs to</param>
            <param name="value">Boolean Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsString">
            <summary>
            Gets the string value of the boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsInteger">
            <summary>
            Throws an error as booleans cannot be cast to integers
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsDecimal">
            <summary>
            Throws an error as booleans cannot be cast to decimals
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsFloat">
            <summary>
            Throws an error as booleans cannot be cast to floats
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsDouble">
            <summary>
            Throws an error as booleans cannot be cast to doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsBoolean">
            <summary>
            Gets the boolean value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsDateTime">
            <summary>
            Throws an error as booleans cannot be cast to date times
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsDateTimeOffset">
            <summary>
            Throws an error as booleans cannot be cast to date times
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BooleanNode.AsTimeSpan">
            <summary>
            Throws an error as booleans cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.BooleanNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BooleanNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.ByteNode">
            <summary>
            Valued node representing a byte (8-bit unsigned integer)
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.#ctor(System.Byte,System.String)">
            <summary>
            Creates a new byte valued node
            </summary>
            <param name="value">Byte value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.#ctor(System.Byte)">
            <summary>
            Creates a new byte valued node
            </summary>
            <param name="value">Byte value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.AsInteger">
            <summary>
            Gets the integer value of the byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.AsDecimal">
            <summary>
            Gets the decimal value of the byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.AsFloat">
            <summary>
            Gets the float value of the byte
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ByteNode.AsDouble">
            <summary>
            Gets the float value of the double
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.DecimalNode">
            <summary>
            Valued Node representing decimal nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.#ctor(System.Decimal,System.String)">
            <summary>
            Creates a new decimal valued node
            </summary>
            <param name="value">Decimal value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.#ctor(System.Decimal)">
            <summary>
            Creates a new decimal valued node
            </summary>
            <param name="value">Decimal value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.AsInteger">
            <summary>
            Gets the integer value of the decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.AsDecimal">
            <summary>
            Gets the decimal value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.AsFloat">
            <summary>
            Gets the float value of the decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DecimalNode.AsDouble">
            <summary>
            Gets the double value of the decimal
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.DoubleNode">
            <summary>
            Valued Node representing double values
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.#ctor(System.Double,System.String)">
            <summary>
            Creates a new double valued node
            </summary>
            <param name="value">Double value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.#ctor(System.Double)">
            <summary>
            Creates a new double valued node
            </summary>
            <param name="value">Double value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.AsInteger">
            <summary>
            Gets the integer value of the double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.AsDecimal">
            <summary>
            Gets the decimal value of the double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.AsFloat">
            <summary>
            Gets the float value of the double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.DoubleNode.AsDouble">
            <summary>
            Gets the double value
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.ValuedNodeExtensions">
            <summary>
            Extension Methods related to valued nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.ValuedNodeExtensions.AsValuedNode(VDS.RDF.Nodes.INode)">
            <summary>
            Takes a <see cref="T:VDS.RDF.Nodes.INode">INode</see> and converts it to a <see cref="T:VDS.RDF.Nodes.IValuedNode">IValuedNode</see> if it is not already an instance that implements the interface
            </summary>
            <param name="n">Node</param>
            <returns>Valued Node</returns>
        </member>
        <member name="M:VDS.RDF.Nodes.ValuedNodeExtensions.AsSafeBoolean(VDS.RDF.Nodes.IValuedNode)">
            <summary>
            Tries to get the result of calling <see cref="M:VDS.RDF.Nodes.IValuedNode.AsBoolean">AsBoolean()</see> on a node throwing an error if the node is null
            </summary>
            <param name="n">Node</param>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if the input is null of the specific valued node cannot be cast to a boolean</exception>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.FloatNode">
            <summary>
            A Valued Node representing float values
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.#ctor(System.Single,System.String)">
            <summary>
            Creates a new Float valued node
            </summary>
            <param name="value">Float value</param>
            <param name="lexicalValue">Lexical value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.#ctor(System.Single)">
            <summary>
            Creates a new Float valued node
            </summary>
            <param name="value">Float value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.AsInteger">
            <summary>
            Gets the integer value of the float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.AsDecimal">
            <summary>
            Gets the decimal value of the float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.AsFloat">
            <summary>
            Gets the float value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.FloatNode.AsDouble">
            <summary>
            Gets the double value of the float
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.LongNode">
            <summary>
            A Valued Node with a Long value
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.#ctor(System.Int64,System.String)">
            <summary>
            Creates a new long valued node
            </summary>
            <param name="value">Long value</param>
            <param name="lexicalValue">Lexical Value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.#ctor(System.Int64,System.String,System.Uri)">
            <summary>
            Creates a new long valued node
            </summary>
            <param name="value">Long value</param>
            <param name="lexicalValue">Lexical Value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.#ctor(System.Int64)">
            <summary>
            Creates a new long valued node
            </summary>
            <param name="value">Long value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.AsInteger">
            <summary>
            Gets the long value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.AsDecimal">
            <summary>
            Gets the decimal value of the long
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.AsFloat">
            <summary>
            Gets the float value of the long
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.LongNode.AsDouble">
            <summary>
            Gets the double value of the long
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.StringNode">
            <summary>
            Valued node whose value is a string or can only be converted to a string
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.#ctor(System.String,System.Uri)">
            <summary>
            Creates a new String Node
            </summary>
            <param name="value">String value</param>
            <param name="datatype">Datatype URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.#ctor(System.String,System.String)">
            <summary>
            Creates a new String Node
            </summary>
            <param name="value">String value</param>
            <param name="lang">Language Specifier</param>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.#ctor(System.String)">
            <summary>
            Creates a new String Node
            </summary>
            <param name="value">String value</param>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsString">
            <summary>
            Gets the string value
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsInteger">
            <summary>
            Throws an error as the string cannot be cast to an integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsDecimal">
            <summary>
            Throws an error as the string cannot be cast to a decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsFloat">
            <summary>
            Throws an error as the string cannot be cast to a float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsDouble">
            <summary>
            Throws an error as the string cannot be cast to a double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsBoolean">
            <summary>
            Gets the boolean value of the string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsDateTime">
            <summary>
            Throws an error as the string cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsDateTimeOffset">
            <summary>
            Throws an error as the string cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.StringNode.AsTimeSpan">
            <summary>
            Throws an error as the string cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.StringNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.StringNode.NumericType">
            <summary>
            Gets the numeric type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IGraphFormatter">
            <summary>
            Interface for formatters designed to format entire RDF Graphs
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.ITripleFormatter">
            <summary>
            Interface for Triple Formatters
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.ITripleFormatter.Format(VDS.RDF.Graphs.Triple)">
            <summary>
            Formats a Triple as a String
            </summary>
            <param name="t">Triple</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IGraphFormatter.FormatGraphHeader(VDS.RDF.Graphs.IGraph)">
            <summary>
            Generates the header section for the Graph
            </summary>
            <param name="g">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IGraphFormatter.FormatGraphHeader(VDS.RDF.Namespaces.INamespaceMapper)">
            <summary>
            Generates the header section for the Graph
            </summary>
            <param name="namespaces">Namespaces</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IGraphFormatter.FormatGraphHeader">
            <summary>
            Generates a generic header section
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IGraphFormatter.FormatGraphFooter">
            <summary>
            Generates the footer section
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.ICharFormatter">
            <summary>
            Interface for Character Formatters
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.ICharFormatter.FormatChar(System.Char[])">
            <summary>
            Formats a sequence of characters as a String
            </summary>
            <param name="cs">Characters</param>
            <returns>String</returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.INamespaceFormatter">
            <summary>
            Interface for Formatters which can format Namespace Information
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.INamespaceFormatter.FormatNamespace(System.String,System.Uri)">
            <summary>
            Formats Namespace Information as a String
            </summary>
            <param name="prefix">Namespae Prefix</param>
            <param name="namespaceUri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IBaseUriFormatter">
            <summary>
            Interface for Formatters which can format Base URI Information
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IBaseUriFormatter.FormatBaseUri(System.Uri)">
            <summary>
            Formats Base URI Information as a String
            </summary>
            <param name="u">Base URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.IUriFormatter">
            <summary>
            Interface for URI Formatters
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IUriFormatter.FormatUri(System.Uri)">
            <summary>
            Formats a URI as a String
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.IUriFormatter.FormatUri(System.String)">
            <summary>
            Formats a URI as a String
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Formatting.INodeFormatter">
            <summary>
            Interface for classes which can format Nodes into Strings
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.INodeFormatter.Format(VDS.RDF.Nodes.INode)">
            <summary>
            Formats a Node as a String
            </summary>
            <param name="n">Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.Formatting.INodeFormatter.Format(VDS.RDF.Nodes.INode,System.Nullable{VDS.RDF.Writing.QuadSegment})">
            <summary>
            Formats a Node as a String for a specific segment of a Triple
            </summary>
            <param name="n">Node</param>
            <param name="segment">Segment</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.Serialization.SerializationHelper">
            <summary>
            Helper Class for use in serialization and deserialization
            </summary>
        </member>
        <member name="T:VDS.RDF.Specifications.RdfSpecsHelper">
            <summary>
            Helper class with useful constants relating to the RDF Specification
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfListFirst">
            <summary>
            URI for rdf:first
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfListRest">
            <summary>
            URI for rdf:rest
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfListNil">
            <summary>
            URI for rdf:nil
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfType">
            <summary>
            URI for rdf:type
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfXmlLiteral">
            <summary>
            URI for rdf:XMLLiteral
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfSubject">
            <summary>
            URI for rdf:subject
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfPredicate">
            <summary>
            URI for rdf:predicate
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfObject">
            <summary>
            URI for rdf:object
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfStatement">
            <summary>
            URI for rdf:Statement
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.RdfLangString">
            <summary>
            URI for rdf:langString the implicit type of language specified literals
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper.ValidLangSpecifiersPattern">
            <summary>
            Pattern for Valid Language Specifiers
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfSpecsHelper._validLangSpecifier">
            <summary>
            Regular Expression for Valid Language Specifiers
            </summary>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfSpecsHelper.IsValidLangSpecifier(System.String)">
            <summary>
            Determines whether a given String is a valid Language Specifier
            </summary>
            <param name="value">String to test</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Specifications.XmlSpecsHelper">
            <summary>
            Static Helper Class which contains a set of Functions which model Name and Character validations as laid
            out in the W3C XML and XML Namespaces specification
            </summary>
            <remarks>
            These are needed in the XML/RDF Parser
            
            Also contains the Date Time format string used to format .Net's DateTime type into a String whose format conforms to the XML Schema Datatypes specification
            
            
            </remarks>
            <seealso>http://www.w3.org/TR/REC-xml/</seealso>
            <seealso>http://www.w3.org/TR/REC-xml-names/</seealso>
            <seealso>http://www.w3.org/TR/xmlschema-2/</seealso>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.NamespaceXml">
            <summary>
            Namespace for XML
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.NamespaceXmlNamespaces">
            <summary>
            Namespace for XML Namespaces
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.NamespaceXmlSchema">
            <summary>
            Namespace for XML Schema
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDateTimeFormat">
            <summary>
            Date Time Formatting string which meets the specified format for xsd:dateTime
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDateTimeFormatImprecise">
            <summary>
            Date Time Formatting string which meets the specified format for xsd:dateTime, this formatting string is imprecise in the sense that it does not preserve the fractional seconds.
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDateFormat">
            <summary>
            Date Time Formatting string which meets the specified format for xsd:date
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaTimeFormat">
            <summary>
            Date Time Formatting string which meets the the specified format for xsd:time
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaTimeFormatImprecise">
            <summary>
            Date Time Formatting string which meets the the specified format for xsd:time, this formatting string is imprecise in the sense that it does not preserve the fractional seconds.
            </summary>
            <remarks>
            Use with the <see cref="M:System.DateTime.ToString">DateTime.ToString()</see> method to format a DateTime into appropriate string format
            </remarks>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeAnyUri">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeBase64Binary">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeBoolean">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeByte">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeDate">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeDateTime">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeDayTimeDuration">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeDuration">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeDecimal">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeDouble">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeFloat">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeHexBinary">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeInt">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeLong">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeNegativeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeNonNegativeInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeNonPositiveInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypePositiveInteger">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeShort">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeTime">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeString">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeUnsignedByte">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeUnsignedInt">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeUnsignedLong">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.XmlSchemaDataTypeUnsignedShort">
            <summary>
            Data Type Uri Constants for XML Schema Data Types
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.SupportedTypes">
            <summary>
            Array of Constants for Data Types that are supported by the Literal Node CompareTo method
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.XmlSpecsHelper.IntegerDataTypes">
            <summary>
            Set of XML Schema Data Types which are derived from Integer and can be treated as Integers by SPARQL
            </summary>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.IsName(System.String)">
            <summary>
            Returns whether a String is a Name as defined by the W3C XML Specification
            </summary>
            <param name="name">String to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.IsNCName(System.String)">
            <summary>
            Returns whether a String is a NCName as defined by the W3C XML Namespaces Specification
            </summary>
            <param name="name">String to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml-names/#NT-NCName</see>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.IsNameChar(System.Char)">
            <summary>
            Returns whether a Character is a NameChar as defined by the W3C XML Specification
            </summary>
            <param name="c">Character to Test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-NameChar</see>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.IsNameStartChar(System.Char)">
            <summary>
            Returns whether a Character is a NameChar as defined by the W3C XML Specification
            </summary>
            <param name="c">Character to test</param>
            <returns></returns>
            <see>http://www.w3.org/TR/REC-xml/#NT-NameChar</see>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.IsSupportedType(System.String)">
            <summary>
            Returns whether the given Type refers to one of the types supported by the <see cref="T:VDS.RDF.Nodes.LiteralNode">LiteralNode</see> CompareTo method
            </summary>
            <param name="type">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.IsSupportedType(System.Uri)">
            <summary>
            Returns whether the given Type refers to one of the types supported by the <see cref="T:VDS.RDF.Nodes.LiteralNode">LiteralNode</see> CompareTo method
            </summary>
            <param name="type">Data Type Uri</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.GetSupportedDataType(VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Data Type Uri of the given Node if it has a supported type
            </summary>
            <param name="n">Node</param>
            <returns></returns>
            <remarks>
            <para>
            Onlyliteral nodes can have a Data Type
            </para>
            <para>
            The function only returns the Data Type Uri (as a String) if the Data Type of the Literal is one of the supported Data Types
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.GetCompatibleSupportedDataType(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,System.Boolean)">
            <summary>
            Gets the Compatible Supported Data Type assuming the two Nodes are Literals with support types and that those types are compatible
            </summary>
            <param name="x">A Node</param>
            <param name="y">A Node</param>
            <param name="widen">Whether the compatible type should be the wider type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.GetCompatibleSupportedDataType(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Compatible Supported Data Type assuming the two Nodes are Literals with support types and that those types are compatible
            </summary>
            <param name="x">A Node</param>
            <param name="y">A Node</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.GetCompatibleSupportedDataType(System.String,System.String)">
            <summary>
            Gets the Compatible Supported Data Type for the two Data Types
            </summary>
            <param name="type1">A Data Type</param>
            <param name="type2">A Data Type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Specifications.XmlSpecsHelper.GetCompatibleSupportedDataType(System.String,System.String,System.Boolean)">
            <summary>
            Gets the Compatible Supported Data Type for the two Data Types
            </summary>
            <param name="type1">A Data Type</param>
            <param name="type2">A Data Type</param>
            <param name="widen">Whether the compatible type should be the wider type</param>
            <returns></returns>
            <remarks>
            <para>
            Currently this is only immplemented sufficiently for the types it needs to know are compatible for implementing SPARQL equality and ordering semantics
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Specifications.RdfXmlSpecsHelper">
            <summary>
            Static Helper class for providing Constants and Helper functions for use by RDF/XML parsers
            </summary>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsAbsoluteUri(System.String)">
            <summary>
            Checks whether a Uri Reference is an absolute Uri
            </summary>
            <param name="uriref">Uri Reference to Test</param>
            <returns></returns>
            <remarks>Implemented by seeing if the Uri Reference starts with a Uri scheme specifier</remarks>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfXmlSpecsHelper._coreSyntaxTerms">
            <summary>
            Array containing the Core Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfXmlSpecsHelper._syntaxTerms">
            <summary>
            Array containing the other Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfXmlSpecsHelper._oldTerms">
            <summary>
            Array containing the Old Syntax Terms
            </summary>
        </member>
        <member name="F:VDS.RDF.Specifications.RdfXmlSpecsHelper._requiresRdfPrefix">
            <summary>
            Array containing Syntax Terms where the rdf: Prefix is mandated
            </summary>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsCoreSyntaxTerm(System.String)">
            <summary>
            Checks whether a given QName is a Core Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Core Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsSyntaxTerm(System.String)">
            <summary>
            Checks whether a given QName is a Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsOldTerm(System.String)">
            <summary>
            Checks whether a given QName is a Old Syntax Term
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is a Old Syntax Term</returns>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsNodeElementUri(System.String)">
            <summary>
            Checks whether a given QName is valid as a Node Element Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsPropertyElementUri(System.String)">
            <summary>
            Checks whether a given QName is valid as a Property Element Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsPropertyAttributeUri(System.String)">
            <summary>
            Checks whether a given QName is valid as a Property Attribute Uri
            </summary>
            <param name="qname">QName to Test</param>
            <returns>True if the QName is valid</returns>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsAmbigiousAttributeName(System.String)">
            <summary>
            Checks whether a given Local Name is potentially ambigious
            </summary>
            <param name="name">Local Name to Test</param>
            <returns>True if the Local Name is ambigious</returns>
            <remarks>This embodies Local Names which must have an rdf prefix</remarks>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsValidUriRefEncoding(System.String)">
            <summary>
            Checks whether a given URIRef is encoded in Unicode Normal Form C
            </summary>
            <param name="uriref">URIRef to Test</param>
            <returns>True if the URIRef is encoded correctly</returns>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsValidBaseUri(System.String)">
            <summary>
            Checks whether a given Base Uri can be used for relative Uri resolution
            </summary>
            <param name="baseUri">Base Uri to Test</param>
            <returns>True if the Base Uri can be used for relative Uri resolution</returns>
        </member>
        <member name="M:VDS.RDF.Specifications.RdfXmlSpecsHelper.IsValidQName(System.String)">
            <summary>
            Determines whether a QName is valid for use in RDF/XML
            </summary>
            <param name="qname">QName</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Writing.WriterCompressionLevel">
            <summary>
            Class containing constants for possible Compression Levels
            </summary>
            <remarks>These are intended as guidance only, Writer implementations are free to interpret these levels as they desire or to ignore them entirely and use their own levels</remarks>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.None">
            <summary>
            No Compression should be used (-1)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Minimal">
            <summary>
            Minimal Compression should be used (0)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Default">
            <summary>
            Default Compression should be used (1)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.Medium">
            <summary>
            Medium Compression should be used (3)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.More">
            <summary>
            More Compression should be used (5)
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.WriterCompressionLevel.High">
            <summary>
            High Compression should be used (10)
            </summary>
        </member>
        <member name="T:VDS.RDF.Writing.WriterHelper">
            <summary>
            Helper methods for writers
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.IsValidBlankNodeId(System.String)">
            <summary>
            Determines whether a Blank Node ID is valid as-is when serialised in NTriple like syntaxes (Turtle/N3/SPARQL)
            </summary>
            <param name="id">ID to test</param>
            <returns></returns>
            <remarks>If false is returned then the writer will alter the ID in some way</remarks>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.IsValidStrictBlankNodeId(System.String)">
            <summary>
            Determines whether a Blank Node ID is valid as-is when serialised as NTriples
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.EncodeForXml(System.String)">
            <summary>
            Encodes values for use in XML
            </summary>
            <param name="value">Value to encode</param>
            <returns>
            The value with any ampersands escaped to &amp;
            </returns>
        </member>
        <member name="M:VDS.RDF.Writing.WriterHelper.ExtractNamespaces(VDS.RDF.Graphs.IGraphStore)">
            <summary>
            Extracts all namespaces used by graphs within the store
            </summary>
            <param name="store">Graph store</param>
            <returns>Namespaces</returns>
        </member>
        <member name="T:VDS.RDF.Writing.BlankNodeOutputMapper">
            <summary>
            Mapper class which remaps Blank Node GUIDs into string IDs for output
            </summary>
        </member>
        <member name="F:VDS.RDF.Writing.BlankNodeOutputMapper.DefaultOutputPrefix">
            <summary>
            Default prefix prepended to the numeric IDs produced by this mapper
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.BlankNodeOutputMapper.#ctor">
            <summary>
            Creates a new mapper using the default settings
            </summary>
        </member>
        <member name="M:VDS.RDF.Writing.BlankNodeOutputMapper.#ctor(System.String)">
            <summary>
            Creates a new mapper using a custom blank node prefix
            </summary>
            <param name="prefix">Prefix</param>
            <remarks>
            <para>
            It is up to the user to ensure that the the prefix given will result in valid blank node identifiers for any usage the generated string IDs are put to
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Writing.BlankNodeOutputMapper.GetOutputId(System.Guid)">
            <summary>
            Takes a GUID and generates a valid output ID
            </summary>
            <param name="id">ID</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Writing.BlankNodeOutputMapper.GetNextId">
            <summary>
            Internal Helper function which generates the new IDs
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.BaseBlankNode">
            <summary>
            Abstract Base Class for Blank Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.#ctor(System.Guid)">
            <summary>
            Internal Only Constructor for Blank Nodes
            </summary>
            <param name="g">Graph this Node belongs to</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.#ctor">
            <summary>
            Constructor for deserialization usage only
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.Equals(System.Object)">
            <summary>
            Implementation of Equals for Blank Nodes
            </summary>
            <param name="obj">Object to compare with the Blank Node</param>
            <returns></returns>
            <remarks>
            Blank Nodes are considered equal if their internal IDs match precisely and they originate from the same Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.Equals(VDS.RDF.Nodes.INode)">
            <summary>
            Implementation of Equals for Blank Nodes
            </summary>
            <param name="other">Object to compare with the Blank Node</param>
            <returns></returns>
            <remarks>
            Blank Nodes are considered equal if their Anon IDs match precisely and they originate from the same Factory
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.Equals(VDS.RDF.Nodes.BaseBlankNode)">
            <summary>
            Determines whether this Node is equal to a Blank Node
            </summary>
            <param name="other">Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.CompareTo(VDS.RDF.Nodes.INode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.CompareTo(VDS.RDF.Nodes.BaseBlankNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.ToString">
            <summary>
            Returns a string representation of this Blank Node in QName form
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the data for serialization
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsString">
            <summary>
            Throws an error as a Blank Node cannot be cast to a String
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsInteger">
            <summary>
            Throws an error as a Blank Node cannot be cast to an integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsDecimal">
            <summary>
            Throws an error as a Blank Node cannot be cast to a decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsFloat">
            <summary>
            Throws an error as a Blank Node cannot be cast to a float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsDouble">
            <summary>
            Throws an error as a Blank Node cannot be cast to a double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsBoolean">
            <summary>
            Throws an error as a Blank Node cannot be cast to a boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsDateTime">
            <summary>
            Throws an error as a Blank Node cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsDateTimeOffset">
            <summary>
            Throws an error as a Blank Node cannot be cast to a date time offset
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseBlankNode.AsTimeSpan">
            <summary>
            Throws an error as a Blank Node cannot be case to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseBlankNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseBlankNode.NumericType">
            <summary>
            Gets the Numeric Type of the Node
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.BlankNode">
            <summary>
            Class for representing Blank RDF Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BlankNode.#ctor(System.Guid)">
            <summary>
            Internal Only Constructor for Blank Nodes
            </summary>
            <param name="id">ID</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BlankNode.#ctor">
            <summary>
            Constructor for deserialization usage only
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BlankNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BlankNode.CompareTo(VDS.RDF.Nodes.BlankNode)">
            <summary>
            Implementation of Compare To for Blank Nodes
            </summary>
            <param name="other">Blank Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BlankNode.Equals(VDS.RDF.Nodes.BlankNode)">
            <summary>
            Determines whether this Node is equal to a Blank Node
            </summary>
            <param name="other">Blank Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.BaseGraphLiteralNode">
            <summary>
            Abstract Base Class for Graph Literal Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.#ctor(VDS.RDF.Graphs.IGraph)">
            <summary>
            Creates a new Graph Literal Node in the given Graph which represents the given Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
            <param name="subgraph">Sub Graph this node represents</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.#ctor">
            <summary>
            Creates a new Graph Literal Node whose value is an empty Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializer Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.Equals(System.Object)">
            <summary>
            Implementation of the Equals method for Graph Literal Nodes.  Graph Literals are considered Equal if their respective Subgraphs are equal
            </summary>
            <param name="obj">Object to compare the Node with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.Equals(VDS.RDF.Nodes.INode)">
            <summary>
            Implementation of the Equals method for Graph Literal Nodes.  Graph Literals are considered Equal if their respective Subgraphs are equal
            </summary>
            <param name="other">Object to compare the Node with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.Equals(VDS.RDF.Nodes.BaseGraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.ToString">
            <summary>
            Implementation of ToString for Graph Literals which produces a String representation of the Subgraph in N3 style syntax
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.CompareTo(VDS.RDF.Nodes.INode)">
            <summary>
            Implementation of CompareTo for Graph Literals
            </summary>
            <param name="other">Node to compare to</param>
            <returns></returns>
            <remarks>
            Graph Literal Nodes are greater than Blank Nodes, Uri Nodes, Literal Nodes and Nulls
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.CompareTo(VDS.RDF.Nodes.BaseGraphLiteralNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the Serialization Information
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsString">
            <summary>
            Throws an error as Graph Literals cannot be cast to a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsInteger">
            <summary>
            Throws an error as Graph Literals cannot be cast to an integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsDecimal">
            <summary>
            Throws an error as Graph Literals cannot be cast to a decimal
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsFloat">
            <summary>
            Throws an error as Graph Literals cannot be cast to a float
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsDouble">
            <summary>
            Throws an error as Graph Literals cannot be cast to a double
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsBoolean">
            <summary>
            Throws an error as Graph Literals cannot be cast to a boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsDateTime">
            <summary>
            Throws an error as Graph Literals cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsDateTimeOffset">
            <summary>
            Throws an error as Graph Literals cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseGraphLiteralNode.AsTimeSpan">
            <summary>
            Throws an error as Graph Literals cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseGraphLiteralNode.SubGraph">
            <summary>
            Gets the Subgraph that this Node represents
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseGraphLiteralNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseGraphLiteralNode.NumericType">
            <summary>
            Gets the numeric type of the node
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.GraphLiteralNode">
            <summary>
            Class for representing Graph Literal Nodes which are supported in highly expressive RDF syntaxes like Notation 3
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.GraphLiteralNode.#ctor(VDS.RDF.Graphs.IGraph)">
            <summary>
            Creates a new Graph Literal Node whose value is an empty Subgraph
            </summary>
            <param name="g">Graph this node is in</param>
            <param name="subgraph">Sub-graph this node represents</param>
        </member>
        <member name="M:VDS.RDF.Nodes.GraphLiteralNode.#ctor">
            <summary>
            Deserialization only constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.GraphLiteralNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.GraphLiteralNode.CompareTo(VDS.RDF.Nodes.GraphLiteralNode)">
            <summary>
            Implementation of Compare To for Graph Literal Nodes
            </summary>
            <param name="other">Graph Literal Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.GraphLiteralNode.Equals(VDS.RDF.Nodes.GraphLiteralNode)">
            <summary>
            Determines whether this Node is equal to a Graph Literal Node
            </summary>
            <param name="other">Graph Literal Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.NodeFactory">
            <summary>
            A default implementation of a Node Factory
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.#ctor">
            <summary>
            Creates a new Node Factory
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateBlankNode">
            <summary>
            Creates a Blank Node with a new automatically generated ID
            </summary>
            <returns></returns>
            <remarks>
            A factory should always return a fresh blank node when this method is invoked
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateBlankNode(System.Guid)">
            <summary>
            Creates a new blank node with the given ID
            </summary>
            <param name="id">ID</param>
            <returns>Blank node</returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateGraphLiteralNode">
            <summary>
            Creates a Graph Literal Node which represents the empty Subgraph
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateGraphLiteralNode(VDS.RDF.Graphs.IGraph)">
            <summary>
            Creates a Graph Literal Node which represents the given Subgraph
            </summary>
            <param name="subgraph">Subgraph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateLiteralNode(System.String,System.Uri)">
            <summary>
            Creates a Literal Node with the given Value and Data Type
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="datatype">Data Type URI of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateLiteralNode(System.String)">
            <summary>
            Creates a Literal Node with the given Value
            </summary>
            <param name="literal">Value of the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateLiteralNode(System.String,System.String)">
            <summary>
            Creates a Literal Node with the given Value and Language
            </summary>
            <param name="literal">Value of the Literal</param>
            <param name="langspec">Language Specifier for the Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateUriNode(System.Uri)">
            <summary>
            Creates a URI Node for the given URI
            </summary>
            <param name="uri">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.NodeFactory.CreateVariableNode(System.String)">
            <summary>
            Creates a Variable Node for the given Variable Name
            </summary>
            <param name="varname"></param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.NodeFactory.CreatesImplicitlyTypedLiterals">
            <summary>
            Indicates whether this factory produces RDF 1.1 literals
            </summary>
            <remarks>
            <para>
            If true then calling <see cref="M:VDS.RDF.Nodes.NodeFactory.CreateLiteralNode(System.String)"/> will produce a literal typed as xsd:string and calling <see cref="M:VDS.RDF.Nodes.NodeFactory.CreateLiteralNode(System.String,System.String)"/> will produce a literal typed as rdf:langString.  If false then literals are created only with the fields provided.
            </para>
            <para>
            This instance respects the global <see cref="P:VDS.RDF.Options.Rdf11"/> setting and thus its return value is dictated by the value of that setting
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Nodes.BaseUriNode">
            <summary>
            Abstract Base Class for URI Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.#ctor(System.Uri)">
            <summary>
            Internal Only Constructor for URI Nodes
            </summary>
            <param name="uri">URI</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.Equals(System.Object)">
            <summary>
            Implementation of Equality for Uri Nodes
            </summary>
            <param name="obj">Object to compare with</param>
            <returns></returns>
            <remarks>
            URI Nodes are considered equal if their various segments are equivalent based on URI comparison rules, see <see cref="!:EqualityHelper.AreUrisEqual()"/>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.Equals(VDS.RDF.Nodes.INode)">
            <summary>
            Implementation of Equality for Uri Nodes
            </summary>
            <param name="other">Object to compare with</param>
            <returns></returns>
            <remarks>
            URI Nodes are considered equal if the string form of their URIs match using Ordinal string comparison
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.Equals(VDS.RDF.Nodes.BaseUriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.ToString">
            <summary>
            Gets a String representation of a Uri as a plain text Uri
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.CompareTo(VDS.RDF.Nodes.INode)">
            <summary>
            Implementation of Compare To for Uri Nodes
            </summary>
            <param name="other">Node to Compare To</param>
            <returns></returns>
            <remarks>
            Uri Nodes are greater than Blank Nodes and Nulls, they are less than Literal Nodes and Graph Literal Nodes.
            <br /><br />
            Uri Nodes are ordered based upon lexical ordering of the string value of their URIs
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.CompareTo(VDS.RDF.Nodes.BaseUriNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the data for serialization
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsString">
            <summary>
            Gets the value of the node as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsInteger">
            <summary>
            Throws an error as URIs cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsDecimal">
            <summary>
            Throws an error as URIs cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsFloat">
            <summary>
            Throws an error as URIs cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsDouble">
            <summary>
            Throws an error as URIs cannot be cast to numerics
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsBoolean">
            <summary>
            Throws an error as URIs cannot be cast to a boolean
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsDateTime">
            <summary>
            Throws an error as URIs cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsDateTimeOffset">
            <summary>
            Throws an error as URIs cannot be cast to a date time
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseUriNode.AsTimeSpan">
            <summary>
            Throws an error as URIs cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseUriNode.Uri">
            <summary>
            Gets the Uri for this Node
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseUriNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseUriNode.NumericType">
            <summary>
            Gets the numeric type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.UriNode">
            <summary>
            Class for representing URI Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.UriNode.#ctor(System.Uri)">
            <summary>
            Internal Only Constructor for URI Nodes
            </summary>
            <param name="g">Graph this Node is in</param>
            <param name="uri">URI for the Node</param>
        </member>
        <member name="M:VDS.RDF.Nodes.UriNode.#ctor">
            <summary>
            Deserilization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.UriNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.UriNode.CompareTo(VDS.RDF.Nodes.UriNode)">
            <summary>
            Implementation of Compare To for URI Nodes
            </summary>
            <param name="other">URI Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.UriNode.Equals(VDS.RDF.Nodes.UriNode)">
            <summary>
            Determines whether this Node is equal to a URI Node
            </summary>
            <param name="other">URI Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.BaseVariableNode">
            <summary>
            Abstract Base Class for Variable Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.#ctor(System.String)">
            <summary>
            Creates a new Variable Node
            </summary>
            <param name="g">Graph</param>
            <param name="varname">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.Equals(VDS.RDF.Nodes.INode)">
            <summary>
            Gets whether this Node is equal to some other Node
            </summary>
            <param name="other">Node to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.Equals(VDS.RDF.Nodes.BaseVariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.Equals(System.Object)">
            <summary>
            Gets whether this Node is equal to some Object
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.ToString">
            <summary>
            Gets the String representation of this Node
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.CompareTo(VDS.RDF.Nodes.INode)">
            <summary>
            Compares this Node to another Node
            </summary>
            <param name="other">Node to compare with</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.CompareTo(VDS.RDF.Nodes.BaseVariableNode)">
            <summary>
            Returns an Integer indicating the Ordering of this Node compared to another Node
            </summary>
            <param name="other">Node to test against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the data for serialization
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsString">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsInteger">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsDecimal">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsFloat">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsDouble">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsBoolean">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsDateTime">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsDateTimeOffset">
            <summary>
            Throws an error as variables cannot be converted to types
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.BaseVariableNode.AsTimeSpan">
            <summary>
            Throws an error as variables cannot be cast to a time span
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseVariableNode.VariableName">
            <summary>
            Gets the Variable Name
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseVariableNode.EffectiveType">
            <summary>
            Gets the URI of the datatype this valued node represents as a String
            </summary>
        </member>
        <member name="P:VDS.RDF.Nodes.BaseVariableNode.NumericType">
            <summary>
            Gets the numeric type of the expression
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.VariableNode">
            <summary>
            Class representing Variable Nodes (only used for N3)
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.VariableNode.#ctor(System.String)">
            <summary>
            Creates a new Variable Node
            </summary>
            <param name="g">Graph</param>
            <param name="varname">Variable Name</param>
        </member>
        <member name="M:VDS.RDF.Nodes.VariableNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.VariableNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.VariableNode.CompareTo(VDS.RDF.Nodes.VariableNode)">
            <summary>
            Compares this Node to another Variable Node
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.VariableNode.Equals(VDS.RDF.Nodes.VariableNode)">
            <summary>
            Determines whether this Node is equal to a Variable Node
            </summary>
            <param name="other">Variable Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.BaseGraph">
            <summary>
            Abstract Base Implementation of the <see cref="T:VDS.RDF.Graphs.IGraph">IGraph</see> interface
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.BaseGraph._triples">
            <summary>
            Collection of Triples in the Graph
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.BaseGraph._nsmapper">
            <summary>
            Namespace Mapper
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.#ctor(VDS.RDF.Collections.ITripleCollection)">
            <summary>
            Creates a new Base Graph using the given Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection to use</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.#ctor">
            <summary>
            Creates a new Base Graph which uses the default <see cref="T:VDS.RDF.Collections.TreeIndexedTripleCollection"/> as the Triple Collection
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a Graph from the given Serialization Information
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.Assert(VDS.RDF.Graphs.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.Retract(VDS.RDF.Graphs.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted</remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.Clear">
            <summary>
            Clears all Triples from the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.CreateUriNode(System.String)">
            <summary>
            Creates a new URI Node with the given prefixed name
            </summary>
            <param name="prefixedName">Prefixed name for the Node</param>
            <returns>URI Node</returns>
            <remarks>Internally the Graph will resolve the prefixed name to a full URI, this throws an exception when this is not possible</remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.Find(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Finds triples matching the given search criteria i.e. those where the given nodes occur in the appropriate position(s).  Null values are considered wildcards for a position.
            </summary>
            <param name="s">Subject</param>
            <param name="p">Predicate</param>
            <param name="o">Object</param>
            <returns>Triples</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.ContainsTriple(VDS.RDF.Graphs.Triple)">
            <summary>
            Gets whether a given Triple exists in this Graph
            </summary>
            <param name="t">Triple to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.Equals(System.Object)">
            <summary>
            Determines whether a Graph is equal to another Object
            </summary>
            <param name="obj">Object to test</param>
            <returns></returns>
            <remarks>
            Graphs are only considered equal if they have the same reference, to check if two graphs are equivalent use the <see cref="M:VDS.RDF.GraphExtensions.IsIsomorphicWith(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)"/> method
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.ToDataTable">
            <summary>
            Converts a Graph into a DataTable using the explicit cast operator defined by this class
            </summary>
            <returns>
            A DataTable containing three Columns (Subject, Predicate and Object) all typed as <see cref="T:VDS.RDF.Nodes.INode">INode</see> with a Row per Triple
            </returns>
            <remarks>
            <strong>Warning:</strong> Not available under builds which remove the Data Storage layer from dotNetRDF e.g. Silverlight
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.op_Explicit(VDS.RDF.Graphs.BaseGraph)~System.Data.DataTable">
            <summary>
            Casts a Graph to a DataTable with all Columns typed as <see cref="T:VDS.RDF.Nodes.INode">INode</see> (Column Names are Subject, Predicate and Object
            </summary>
            <param name="g">Graph to convert</param>
            <returns>
            A DataTable containing three Columns (Subject, Predicate and Object) all typed as <see cref="T:VDS.RDF.Nodes.INode">INode</see> with a Row per Triple
            </returns>
            <remarks>
            <strong>Warning:</strong> Not available under builds which remove the Data Storage layer from dotNetRDF e.g. Silverlight
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.AttachEventHandlers">
            <summary>
            Attachs the event handles to the underying <see cref="T:VDS.RDF.Collections.ITripleCollection"/>
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.HandleTripleCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Helper method used to catch the <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> from the underlying <see cref="T:VDS.RDF.Collections.ITripleCollection"/> and propogate the event up through this graphs <see cref="E:VDS.RDF.Graphs.BaseGraph.CollectionChanged"/> event
            </summary>
            <param name="sender">Sender</param>
            <param name="args">Arguments</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.RaiseCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises the collection changed event
            </summary>
            <param name="args">Collection changed arguments</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.Dispose">
            <summary>
            Disposes of a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the Serialization Information for serializing a Graph
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.GetSchema">
            <summary>
            Gets the Schema for XML Serialization
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseGraph.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.Triples">
            <summary>
            Gets the set of Triples in this Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.Quads">
            <summary>
            Gets the set of Quads in the graph
            </summary>
            <remarks>
            Since a graph has no name directly associated with it the resulting quads will have the null name assigned to them and so will appears as if in the default unnamed graph
            </remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.Vertices">
            <summary>
            Gets the nodes that are used as vertices in the graph i.e. those which occur in the subject or object position of a triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.Edges">
            <summary>
            Gets the nodes that are used as edges in the graph i.e. those which occur in the predicate position of a triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.Namespaces">
            <summary>
            Gets the Namespace Mapper for this Graph which contains all in use Namespace Prefixes and their URIs
            </summary>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.Count">
            <summary>
            Gets the number of triples in the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.IsEmpty">
            <summary>
            Gets whether a Graph is Empty ie. Contains No Triples or Nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.Capabilities">
            <summary>
            Gets the capabilities of the graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.BaseGraph.HasEvents">
            <summary>
            Gets whether the graph has events
            </summary>
        </member>
        <member name="E:VDS.RDF.Graphs.BaseGraph.CollectionChanged">
            <summary>
            Events which is raised when the graph changes
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.GraphStore">
            <summary>
            In-memory implementation of a Graph/Quad store that uses a <see cref="T:VDS.RDF.Collections.IGraphCollection"/> behind the scenes
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.IGraphStore">
            <summary>
            Interface for Graph Stores, an extension of an <see cref="T:VDS.RDF.Graphs.IQuadStore"/> that allows the data to be accessed in terms of <see cref="T:VDS.RDF.Graphs.IGraph"/> instances
            </summary>
            <remarks>
            <para>
            This interface is a hybrid of the old ITripleStore and ISparqlDataset interfaces from the 1.0 APIs, it allows for data to be manipulated at either the Graph, Triple or Quad level as desired.
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraphStore.Add(VDS.RDF.Graphs.IGraph)">
            <summary>
            Adds the contents of a Graph to the stores default unnamed graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraphStore.Add(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Adds the contents of a Graph to the store using the given graph name for the added Quads
            </summary>
            <param name="graphName">Name of the Graph to add to</param>
            <param name="g">Graph</param>
            <remarks>
            <em>null</em> or <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> may be used to access the default unnamed graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraphStore.Copy(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,System.Boolean)">
            <summary>
            Copies the contents of one graph to another
            </summary>
            <param name="srcName">Source Graph name</param>
            <param name="destName">Target Graph name</param>
            <param name="overwrite">If true the contents of the target graph are overwritten, if false the copied data is added to the existing data in the target graph</param>
            <remarks>
            <em>null</em> or <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> may be used to access the default unnamed graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraphStore.Move(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,System.Boolean)">
            <summary>
            Moves the contents of one graph to another
            </summary>
            <param name="srcName">Source Graph name</param>
            <param name="destName">Destination Graph name</param>
            <param name="overwrite">If true the contents of the target graph are overwritten, if false the moved data is added to the existing data in the target graph</param>
            <remarks>
            <em>null</em> or <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> may be used to access the default unnamed graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraphStore.Remove(VDS.RDF.Graphs.IGraph)">
            <summary>
            Removes the contents of the given graph from the stores default unnamed graph
            </summary>
            <param name="g">Graph</param>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraphStore.Remove(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Removes the contents of the given graph from a specific graph in the store
            </summary>
            <param name="graphName">Graph name</param>
            <param name="g">Graph</param>
            <remarks>
            <em>null</em> or <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> may be used to access the default unnamed graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.IGraphStore.Remove(VDS.RDF.Nodes.INode)">
            <summary>
            Removes the contents of the graph with the given URI
            </summary>
            <param name="graphName">Graph name</param>
            <remarks>
            <em>null</em> or <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> may be used to access the default unnamed graph
            </remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraphStore.Graphs">
            <summary>
            Gets the Graphs in the Store
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.IGraphStore.Item(VDS.RDF.Nodes.INode)">
            <summary>
            Gets a specific Graph from the Store
            </summary>
            <param name="graphName">Graph name</param>
            <returns>A Graph if it exists in the Store, an error otherwise</returns>
            <remarks>
            <em>null</em> or <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/> may be used to access the default unnamed graph
            </remarks>
        </member>
        <member name="F:VDS.RDF.Graphs.GraphStore._graphs">
            <summary>
            The graph collection being used
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.GraphStore.#ctor">
            <summary>
            Creates a new graph store using the default graph collection implementation
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.GraphStore.#ctor(VDS.RDF.Collections.IGraphCollection)">
            <summary>
            Creates a new graph store using the given graph collection
            </summary>
            <param name="collection">Graph Collection</param>
        </member>
        <member name="T:VDS.RDF.Graphs.Graph">
            <summary>
            Class for representing RDF Graphs
            </summary>
            <threadsafety instance="false">Safe for multi-threaded read-only access but unsafe if one/more threads may modify the Graph by using the <see cref="M:VDS.RDF.Graphs.Graph.Assert(VDS.RDF.Graphs.Triple)">Assert</see>, <see cref="M:VDS.RDF.Graphs.Graph.Retract(VDS.RDF.Graphs.Triple)">Retract</see> or <see cref="!:BaseGraph.Merge(IGraph)">Merge</see> methods</threadsafety>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.#ctor">
            <summary>
            Creates a new instance of a Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of a Graph with an optionally empty Namespace Map
            </summary>
            <param name="emptyNamespaceMap">Whether the Namespace Map should be empty</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.#ctor(VDS.RDF.Collections.ITripleCollection)">
            <summary>
            Creates a new instance of a Graph using the given Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.#ctor(VDS.RDF.Collections.ITripleCollection,System.Boolean)">
            <summary>
            Creates a new instance of a Graph using the given Triple Collection and an optionally empty Namespace Map
            </summary>
            <param name="tripleCollection">Triple Collection</param>
            <param name="emptyNamespaceMap">Whether the Namespace Map should be empty</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.Assert(VDS.RDF.Graphs.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.Retract(VDS.RDF.Graphs.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted</remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Graph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="T:VDS.RDF.Graphs.NonIndexedGraph">
            <summary>
            Class for representing RDF Graphs when you don't want Indexing
            </summary>
            <remarks>
            Gives better load performance but poorer lookup performance
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.NonIndexedGraph.#ctor">
            <summary>
            Creates a new Graph which is not indexed
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.Utilities.GraphDiff">
            <summary>
            Implementation of a Graph Difference algorithm for RDF Graphs
            </summary>
            <remarks>
            <para>
            This algorithm is broadly based upon the methodology for computing differences in RDF Graphs described in the <a href="http://www.springerlink.com/index/lq65211003774313.pdf">RDFSync</a> paper by Tummarello et al.  This is an implementation purely of a difference algorithm and not the synchronisation aspects described in their paper.  Main difference between their algorithm and mine is that mine does not make the input Graphs lean as it is concerned with showing the raw differences between the Graphs and does not concern itself with whether the differences may be semantically irrelevant.
            </para>
            <para>
            To understand this consider the following Graphs:
            </para>
            <h2>Graph A</h2>
            <code>
            _:autos1 rdfs:label "Rob" .
            </code>
            <h2>Graph B</h2>
            <code>
            _:autos1 rdfs:label "Rob" .
            _:autos2 rdfs:label "Rob" .
            </code>
            <para>
            Given these Graphs computing the Graph Difference between A and B would report an Added MSG (Minimal Spanning Graph) when in fact the 2nd Graph is non-lean and could be reduced to the same as the 1st Graph
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphDiff.Difference(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)">
            <summary>
            Calculates the Difference between the two Graphs i.e. the changes required to get from the 1st Graph to the 2nd Graph
            </summary>
            <param name="a">First Graph</param>
            <param name="b">Second Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphDiff.ComputeMSGs(VDS.RDF.Graphs.IGraph,System.Collections.Generic.HashSet{VDS.RDF.Graphs.Triple},System.Collections.Generic.List{VDS.RDF.Graphs.IGraph})">
            <summary>
            Computes MSGs for a Graph
            </summary>
            <param name="g">Graph</param>
            <param name="unassigned">Triples that need assigning to MSGs</param>
            <param name="msgs">MSGs list to populate</param>
        </member>
        <member name="T:VDS.RDF.Graphs.Utilities.GraphDiffReport">
            <summary>
            Represents the Differences between 2 Graphs
            </summary>
            <remarks>
            <para>
            The Diff represents the Difference between the 2 Graphs at the time the Difference was calculated - if the Graphs subsequently change then the Diff must be recalculated
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.GraphDiffReport.AreEqual">
            <summary>
            Gets whether the Graphs were equal at the time the Diff was calculated
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.GraphDiffReport.AreDifferentSizes">
            <summary>
            Gets whether the Graphs are different sizes, different sized graphs are by definition non-equal
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.GraphDiffReport.Mapping">
            <summary>
            Provides the mapping from Blank Nodes in 1 Graph to Blank Nodes in another
            </summary>
            <remarks>
            <para>
            In the case of Equal Graphs this will be a complete mapping, if the Graphs are different then it will be an empty/partial mapping depending on whether Blank Nodes can be mapped from one Graph to another or not
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.GraphDiffReport.AddedTriples">
            <summary>
            Gets the Ground Triples (i.e. no Blank Nodes) that must be added to the 1st Graph to get the 2nd Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.GraphDiffReport.RemovedTriples">
            <summary>
            Gets the Ground Triples (i.e. no Blank Nodes) that must be removed from the 1st Graph to get the 2nd Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.GraphDiffReport.AddedMSGs">
            <summary>
            Gets the MSGs (Minimal Spanning Graphs i.e. sets of Triples sharing common Blank Nodes) that must be added to the 1st Graph to get the 2nd Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.GraphDiffReport.RemovedMSGs">
            <summary>
            Gets the MSGs (Minimal Spanning Graphs i.e. sets of Triples sharing common Blank Nodes) that must be added to the 1st Graph to get the 2nd Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.Utilities.GraphSizeComparer">
            <summary>
            A Comparer for Graphs which compares based on number of Triples
            </summary>
            <remarks>
            Used internally in computing Graph Differences but made a public Graph as it may occasionally come in useful
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphSizeComparer.Compare(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)">
            <summary>
            Compares Graphs based on their number of Triples
            </summary>
            <param name="x">Graph</param>
            <param name="y">Graph</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.Utilities.GraphMatcher">
            <summary>
            Implements a Graph Isomorphism Algorithm
            </summary>
            <remarks>
            <para>
            The algorithm used to determine Graph equality is based in part on a Iterative Vertex Classification Algorithm described in a Technical Report from HP by Jeremy J Carroll - <a href="http://www.hpl.hp.com/techreports/2001/HPL-2001-293.html">Matching RDF Graphs</a> but has been expanded upon significantly to use a variety of techniques.
            </para>
            <para>
            Graph Equality is determined according to the following algorithm, we refer to the first graph as the <em>Source Graph</em> and the second graph as the <em>Target Graph</em>:
            </para>
            <ol>
            <li>If both graphs are null they are considered equal</li>
            <li>If only one of the given graph is null then they are not equal</li>
            <li>If the given graphs are reference equal then they are equal</li>
            <li>If the given graphs have a different number of Triples they are not equal</li>
            <li>Declare a list of triples which are the triples of the second graph called <em>TargetTriples</em></li>
            <li>Declare two dictionaries of Nodes to Integers which are called <em>SourceClassification</em> and <em>TargetClassification</em></li>
            <li>For Each Triple in the Source Graph
                <ol>
                <li>If it is a ground triple and cannot be found and removed from <em>TargetTriples</em> then graphs are not equal since the triple does not exist in both graphs</li>
                <li>If it contains blank nodes track the number of usages of this blank node in <em>SourceClassification</em></li>
                </ol>
            </li> 
            <li>If there are any triples remaining in <em>TargetTriples</em> which are ground triples then graphs are not equal since the Source Graph does not contain them</li>
            <li>If all the triples from both graphs were ground triples (i.e. there were no blank nodes) then the graphs are equal</li>
            <li>Iterate over the remaining triples in <em>TargetTriples</em> and populate the <em>TargetClassification</em></li>
            <li>If the count of the two classifications is different the graphs are not equal since there are differing numbers of blank nodes in the Graph</li>
            <li>Now build two additional dictionaries of Integers to Integers which are called <em>SourceDegreeClassification</em> and <em>TargetDegreeClassification</em>.  Iterate over <em>SourceClassification</em> and <em>TargetClassification</em> such that the corresponding degree classifications contain a mapping of the number of blank nodes with a given degree</li>
            <li>If the count of the two degree classifications is different the graphs are not equal since there are not the same range of blank node degrees in both graphs</li>
            <li>For All classifications in <em>SourceDegreeClassification</em> there must be a matching classification in <em>TargetDegreeClassification</em> else the graphs are not equal</li>
            <li>Then build a possible mapping using the following rules:
                <ol>
                <li>Any blank bode used only once (single-use) in the Source Graph should be mapped to an equivalent blank bode in the Target Graph.  If this is not possible then the graphs are not equal</li>
                <li>Any blank node with a unique degree in the Source Graph should be mapped to an equivalent blank node in the Target Graph.  If this is not possible then the graphs are not equal</li>
                <li>Any blank node used with unique constants (two other ground terms in a triple) in the Source Graph should be mapped to an equivalent blank bode in the Target Graph.  If this is not possible then the graphs are not equal.</li>
                <li>Build up lists of dependent pairs of blank Nodes for both graphs</li>
                <li>Use these lists to determine if there are any independent nodes not yet mapped in the Source Graph.  These should be mapped to equivalent blank nodes in the Target Graph, if this is not possible the graphs are not equal</li>
                <li><strong>Important:</strong> Keep a copy of the mapping up to this point as a <em>Base Mapping</em> for use as a fallback in later steps</li>
                <li>Use the dependency information and existing mappings to generate a possible mapping</li>
                <li>If a complete possible mapping (there is a mapping for each blank node from the Source Graph to the Target Graph) then test this mapping.  If it succeeds then the graphs are equal</li>
                </ol>
            </li>
            <li>If we don't yet have a mapping take a divide and conquer approach:
                <ol>
                <li>Take the not yet mapped blank nodes for each graph and sub-divide them into their isolated sub-graphs</li>
                <li>If there are at least 2 isolated sub-graphs proceed to divide and conquer</li>
                <li>For Each Isolated Sub-Graph from the Source Graph
                    <ol>
                    <li>Consider each possible isolated sub-graph of the same size from the target graph, if there are none then graphs are not equal.  If there is a single possible equal isolated sub-graph add the mappings for all involved blank nodes.</li>
                    </ol>
                </li>
                <li>If we now have a complete possible mapping (there is a mapping for each blank node from the Source Graph to the Target Graph) then test the mapping.  Return success/failure depending on whether the mapping is valid.</li>
                <li><strong>Important:</strong> Keep a copy of the mapping up to this point as a <em>Base Mapping</em> for use as a base for the brute force step</li>
                </ol> 
            </li>
            <li>If we still don't have a complete mapping we now fallback to the <em>Base Mapping</em> and use it as a basis for brute forcing the possible solution space and testing every possibility until either a mapping works or we find the graphs to be non-equal</li>
            </ol>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphMatcher.Equals(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)">
            <summary>
            Compares two Graphs for equality
            </summary>
            <param name="g">Graph</param>
            <param name="h">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphMatcher.TryRulesBasedMapping(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            Uses a series of Rules to attempt to generate a mapping without the need for brute force guessing
            </summary>
            <param name="g">1st Graph</param>
            <param name="h">2nd Graph</param>
            <param name="gNodes">1st Graph Node classification</param>
            <param name="hNodes">2nd Graph Node classification</param>
            <param name="gDegrees">1st Graph Degree classification</param>
            <param name="hDegrees">2nd Graph Degree classification</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphMatcher.TryDivideAndConquerMapping(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.List{VDS.RDF.Graphs.Utilities.MappingPair},System.Collections.Generic.List{VDS.RDF.Graphs.Utilities.MappingPair})">
            <summary>
            Uses a divide and conquer based approach to generate a mapping without the need for brute force guessing
            </summary>
            <param name="g">1st Graph</param>
            <param name="h">2nd Graph</param>
            <param name="gNodes">1st Graph Node classification</param>
            <param name="hNodes">2nd Graph Node classification</param>
            <param name="sourceDependencies">Dependencies in the 1st Graph</param>
            <param name="targetDependencies">Dependencies in the 2nd Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphMatcher.TryBruteForceMapping(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.List{VDS.RDF.Graphs.Utilities.MappingPair},System.Collections.Generic.List{VDS.RDF.Graphs.Utilities.MappingPair})">
            <summary>
            Generates and Tests all possibilities in a brute force manner
            </summary>
            <param name="g">1st Graph</param>
            <param name="h">2nd Graph</param>
            <param name="gNodes">1st Graph Node classification</param>
            <param name="hNodes">2nd Graph Node classification</param>
            <param name="sourceDependencies">Dependencies in the 1st Graph</param>
            <param name="targetDependencies">Dependencies in the 2nd Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphMatcher.GenerateMappings(System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode},System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Collections.Generic.List{VDS.RDF.Nodes.INode}})">
            <summary>
            Helper method for brute forcing the possible mappings
            </summary>
            <param name="baseMapping">Base Mapping</param>
            <param name="possibleMappings">Possible Mappings</param>
            <returns></returns>
            <remarks>
            The base mapping at the time of the initial call shoudl contain known good mappings
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.GraphMatcher.GenerateMappingsInternal(System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode},System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Collections.Generic.List{VDS.RDF.Nodes.INode}},VDS.RDF.Nodes.INode)">
            <summary>
            Helper method for brute forcing the possible mappings
            </summary>
            <param name="baseMapping">Base Mapping</param>
            <param name="possibleMappings">Possible Mappings</param>
            <param name="x">Node to consider for mapping</param>
            <returns></returns>
            <remarks>
            The base mapping contains known good mappings
            </remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.GraphMatcher.Mapping">
            <summary>
            Gets the Blank Node Mapping found between the Graphs (if one was found)
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.Utilities.MappingPair">
            <summary>
            Represents a Pair of Nodes that occur in the same Triple
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.Utilities.SubGraphMatcher">
            <summary>
            Implements a Sub-Graph Isomorphism Algorithm
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.SubGraphMatcher.IsSubGraph(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph)">
            <summary>
            Checks to see whether a given Graph is a sub-graph of the other Graph
            </summary>
            <param name="subgraph">Sub-Graph</param>
            <param name="parent">Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.SubGraphMatcher.TryRulesBasedMapping(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
            <summary>
            Uses a series of Rules to attempt to generate a mapping without the need for brute force guessing
            </summary>
            <param name="subgraph">1st Graph</param>
            <param name="parent">2nd Graph</param>
            <param name="subNodes">1st Graph Node classification</param>
            <param name="parentNodes">2nd Graph Node classification</param>
            <param name="subDegrees">1st Graph Degree classification</param>
            <param name="parentDegrees">2nd Graph Degree classification</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.SubGraphMatcher.TryBruteForceMapping(VDS.RDF.Graphs.IGraph,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Int32},System.Collections.Generic.List{VDS.RDF.Graphs.Utilities.MappingPair},System.Collections.Generic.List{VDS.RDF.Graphs.Utilities.MappingPair})">
            <summary>
            Generates and Tests all possibilities in a brute force manner
            </summary>
            <param name="subgraph">1st Graph</param>
            <param name="parent">2nd Graph</param>
            <param name="subNodes">1st Graph Node classification</param>
            <param name="parentNodes">2nd Graph Node classification</param>
            <param name="subDependencies">Dependencies in the 1st Graph</param>
            <param name="parentDependencies">Dependencies in the 2nd Graph</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Utilities.SubGraphMatcher.GenerateMappings(System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,System.Collections.Generic.List{VDS.RDF.Nodes.INode}},System.Collections.Generic.List{VDS.RDF.Graphs.Utilities.MappingPair},System.Collections.Generic.List{VDS.RDF.Graphs.Utilities.MappingPair},VDS.RDF.Graphs.IGraph)">
            <summary>
            Helper method for brute forcing the possible mappings
            </summary>
            <param name="possibleMappings">Possible Mappings</param>
            <param name="subDependencies">Dependencies in the 1st Graph</param>
            <param name="parentDependencies">Dependencies in the 2nd Graph</param>
            <param name="target">Target Graph (2nd Graph)</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Graphs.Utilities.SubGraphMatcher.Mapping">
            <summary>
            Gets the Blank Node mapping if one could be found
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.ThreadSafeGraph">
            <summary>
            A Thread Safe version of the <see cref="T:VDS.RDF.Graphs.Graph">Graph</see> class
            </summary>
            <threadsafety instance="true">Should be safe for almost any concurrent read and write access scenario, internally managed using a <see cref="T:System.Threading.ReaderWriterLockSlim">ReaderWriterLockSlim</see>.  If you encounter any sort of Threading/Concurrency issue please report to the <a href="mailto:dotnetrdf-bugs@lists.sourceforge.net">dotNetRDF Bugs Mailing List</a></threadsafety>
            <remarks>Performance will be marginally worse than a normal <see cref="T:VDS.RDF.Graphs.Graph">Graph</see> but in multi-threaded scenarios this will likely be offset by the benefits of multi-threading.</remarks>
        </member>
        <member name="F:VDS.RDF.Graphs.ThreadSafeGraph._lockManager">
            <summary>
            Locking Manager for the Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ThreadSafeGraph.#ctor">
            <summary>
            Creates a new Thread Safe Graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ThreadSafeGraph.#ctor(VDS.RDF.Collections.BaseTripleCollection)">
            <summary>
            Creates a new Thread Safe graph using the given Triple Collection
            </summary>
            <param name="tripleCollection">Triple Collection</param>
        </member>
        <member name="M:VDS.RDF.Graphs.ThreadSafeGraph.#ctor(VDS.RDF.Collections.ThreadSafeTripleCollection)">
            <summary>
            Creates a new Thread Safe graph using a Thread Safe triple collection
            </summary>
            <param name="tripleCollection">Thread Safe triple collection</param>
        </member>
        <member name="M:VDS.RDF.Graphs.ThreadSafeGraph.Assert(VDS.RDF.Graphs.Triple)">
            <summary>
            Asserts a Triple in the Graph
            </summary>
            <param name="t">The Triple to add to the Graph</param>
        </member>
        <member name="M:VDS.RDF.Graphs.ThreadSafeGraph.Assert(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Asserts a List of Triples in the graph
            </summary>
            <param name="ts">List of Triples in the form of an IEnumerable</param>
        </member>
        <member name="M:VDS.RDF.Graphs.ThreadSafeGraph.Retract(VDS.RDF.Graphs.Triple)">
            <summary>
            Retracts a Triple from the Graph
            </summary>
            <param name="t">Triple to Retract</param>
            <remarks>Current implementation may have some defunct Nodes left in the Graph as only the Triple is retracted</remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.ThreadSafeGraph.Retract(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple})">
            <summary>
            Retracts a enumeration of Triples from the graph
            </summary>
            <param name="ts">Enumeration of Triples to retract</param>
        </member>
        <member name="M:VDS.RDF.Graphs.ThreadSafeGraph.Dispose">
            <summary>
            Disposes of a Graph
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.ThreadSafeGraph.Vertices">
            <summary>
            Gets the nodes that are used as vertices in the graph i.e. those which occur in the subject or object position of a triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.ThreadSafeGraph.Edges">
            <summary>
            Gets the nodes that are used as edges in the graph i.e. those which occur in the predicate position of a triple
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.NonIndexedThreadSafeGraph">
            <summary>
            A Thread Safe version of the <see cref="T:VDS.RDF.Graphs.Graph">Graph</see> class
            </summary>
            <threadsafety instance="true">Should be safe for almost any concurrent read and write access scenario, internally managed using a <see cref="T:System.Threading.ReaderWriterLockSlim">ReaderWriterLockSlim</see>.  If you encounter any sort of Threading/Concurrency issue please report to the <a href="mailto:dotnetrdf-bugs@lists.sourceforge.net">dotNetRDF Bugs Mailing List</a></threadsafety>
            <remarks>
            <para>
            Performance will be marginally worse than a normal <see cref="T:VDS.RDF.Graphs.Graph">Graph</see> but in multi-threaded scenarios this will likely be offset by the benefits of multi-threading.
            </para>
            <para>
            Since this is a non-indexed version load performance will be better but query performance better
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.NonIndexedThreadSafeGraph.#ctor">
            <summary>
            Creates a new non-indexed Thread Safe Graph
            </summary>
        </member>
        <member name="T:VDS.RDF.Graphs.Quad">
            <summary>
            Represents a RDF quad which is a RDF triple with an additional graph name field
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.Quad.DefaultGraphNode">
            <summary>
            Special node instance which represents the default graph
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.#ctor(VDS.RDF.Graphs.Triple,VDS.RDF.Nodes.INode)">
            <summary>
            Creates a new quad
            </summary>
            <param name="t">Triple</param>
            <param name="g">Graph name</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.#ctor(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Creates a new quad
            </summary>
            <param name="subj">Subject</param>
            <param name="pred">Predicate</param>
            <param name="obj">Object</param>
            <param name="graph">graph name</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.AsTriple">
            <summary>
            Converts a Quad into a Triple
            </summary>
            <returns>Triple form of the Quad</returns>
            <remarks>
            <strong>Warning:</strong> This is a lossy information, a Triple does not store any reference to a Graph
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.CopyTo(VDS.RDF.Nodes.INode)">
            <summary>
            Makes a copy of the Quad which is the Quad with a different Graph name
            </summary>
            <param name="graph">Graph name</param>
            <returns></returns>
            <remarks>
            Returns this quad if the Graph name matches that already set for this Quad, otherwise a new Quad is returned
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.Equals(System.Object)">
            <summary>
            Determines whether this quad is equal to some other object
            </summary>
            <param name="obj">Object</param>
            <returns>True if this quad is equal to the other object, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.Equals(VDS.RDF.Graphs.Quad)">
            <summary>
            Determines whether this quad is equal to another quad
            </summary>
            <param name="other">Other quad</param>
            <returns>True if this quad is equal to the other, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.ToString">
            <summary>
            Gets a human readable representation of the quad, this representation is intended for debugging purposes and does not represent a round trippable serialization of a quad.  For that use the <see cref="M:VDS.RDF.Graphs.Quad.ToString(VDS.RDF.Writing.Formatting.IQuadFormatter)"/> overload
            </summary>
            <returns>String representation of the quad</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.ToString(VDS.RDF.Writing.Formatting.IQuadFormatter)">
            <summary>
            Gets the string representation of the quad as formatted by the given formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns>String representation of the quad</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Quad.GetHashCode">
            <summary>
            Gets the hash code of the quad
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="P:VDS.RDF.Graphs.Quad.Subject">
            <summary>
            Gets the subject of the quad
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Quad.Predicate">
            <summary>
            Gets the predicate of the quad
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Quad.Object">
            <summary>
            Gets the object of the quad
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Quad.Graph">
            <summary>
            Gets the graph name for the quad
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Quad.IsGroundQuad">
            <summary>
            Returns whether the quad is grounded i.e. does not contain any blank/variable nodes
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Quad.InDefaultGraph">
            <summary>
            Gets whether this quad belongs to the unnamed default graph
            </summary>
            <remarks>
            This is indicated by the Graph property having the value <see cref="F:VDS.RDF.Graphs.Quad.DefaultGraphNode"/>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Graphs.Triple">
            <summary>
            Class for representing RDF Triples in memory
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.#ctor(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Constructs a Triple from Nodes that belong to the same Graph/Node Factory
            </summary>
            <param name="subj">Subject of the Triple</param>
            <param name="pred">Predicate of the Triple</param>
            <param name="obj">Object of the Triple</param>
            <remarks>Will throw an RdfException if the Nodes don't belong to the same Graph/Node Factory</remarks>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the Nodes aren't all from the same Graph/Node Factory</exception>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.#ctor">
            <summary>
            Deserialization only constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.Involves(VDS.RDF.Nodes.INode)">
            <summary>
            Checks whether the Triple involves a given Node
            </summary>
            <param name="n">The Node to test upon</param>
            <returns>True if the Triple contains the given Node</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.Involves(System.Uri)">
            <summary>
            Checks whether the Triple involves a given Uri
            </summary>
            <param name="uri">The Uri to test upon</param>
            <returns>True if the Triple has a UriNode with the given Uri</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.AsQuad(VDS.RDF.Nodes.INode)">
            <summary>
            Converts the Triple into a Quad
            </summary>
            <param name="graph">Graph name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.Equals(System.Object)">
            <summary>
            Determines whether this triple is equal to some other object
            </summary>
            <param name="obj">Object</param>
            <returns>True if this triple is equal to the other object, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.Equals(VDS.RDF.Graphs.Triple)">
            <summary>
            Determines whether this triple is equal to some other object
            </summary>
            <param name="other">Object</param>
            <returns>True if this triple is equal to the other triple, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.GetHashCode">
            <summary>
            Implementation of Hash Codes for Triples
            </summary>
            <returns></returns>
            <remarks>
            <para>
            Returns the Hash Code of the Triple which is calculated as the Hash Code of the String formed by concatenating the Hash Codes of its constituent Nodes.  This Hash Code is precomputed in the Constructor of a Triple since it will be used a lot (in Triple Equality calculation, Triple Collections etc)
            </para>
            <para>
            Since Hash Codes are based on a String representation there is no guarantee of uniqueness though the same Triple will always give the same Hash Code (on a given Platform - see the MSDN Documentation for <see cref="M:System.String.GetHashCode">string.GetHashCode()</see> for further details) so you should use an appropriate collection to hold them
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.ToString">
            <summary>
            Gets a String representation of a Triple in the form 'Subject , Predicate , Object'
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.ToString(System.Boolean)">
            <summary>
            Gets a String representation of a Triple in the form 'Subject , Predicate , Object' with optional compression of URIs to QNames
            </summary>
            <param name="compress">Controls whether URIs will be compressed to QNames in the String representation</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.ToString(VDS.RDF.Writing.Formatting.ITripleFormatter)">
            <summary>
            Gets the String representation of a Triple using the given Triple Formatter
            </summary>
            <param name="formatter">Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.CompareTo(VDS.RDF.Graphs.Triple)">
            <summary>
            Implementation of CompareTo for Triples which allows Triples to be sorted
            </summary>
            <param name="other">Triple to compare to</param>
            <returns></returns>
            <remarks>Triples are Ordered by Subjects, Predicates and then Objects.  Triples are only partially orderable since the CompareTo methods on Nodes only define a partial ordering over Nodes</remarks>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the data for serialization
            </summary>
            <param name="info">Serilization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.GetSchema">
            <summary>
            Gets the schema for XML serialization
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.ReadXml(System.Xml.XmlReader)">
            <summary>
            Reads the data for XML deserialization
            </summary>
            <param name="reader">XML Reader</param>
        </member>
        <member name="M:VDS.RDF.Graphs.Triple.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writes the data for XML serialization
            </summary>
            <param name="writer">XML Writer</param>
        </member>
        <member name="P:VDS.RDF.Graphs.Triple.Subject">
            <summary>
            Gets the Subject of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Triple.Predicate">
            <summary>
            Gets the Predicate of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Triple.Object">
            <summary>
            Gets the Object of the Triple
            </summary>
        </member>
        <member name="P:VDS.RDF.Graphs.Triple.Graph">
            <summary>
            Gets the Graph this Triple was created for
            </summary>
            <remarks>This is not necessarily the actual Graph this Triple is asserted in since this property is set from the Subject of the Triple when it is created and it is possible to create a Triple without asserting it into an actual Graph or to then assert it into a different Graph.</remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.Triple.GraphUri">
            <summary>
            Gets the Uri of the Graph this Triple was created for
            </summary>
            <remarks>This is not necessarily the actual Graph Uri of the Graph this Triple is asserted in since this property is set from the Subject of the Triple when it is created and it is possible to create a Triple without asserting it into an actual Graph or to then assert it into a different Graph.</remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.Triple.Nodes">
            <summary>
            Gets an enumeration of the Nodes in the Triple
            </summary>
            <remarks>
            Returned as subject, predicate, object
            </remarks>
        </member>
        <member name="P:VDS.RDF.Graphs.Triple.IsGround">
            <summary>
            Gets whether the Triple is a Ground Triple
            </summary>
            <remarks>
            <para>
            A <strong>Ground Triple</strong> is any Triple considered to state a single fixed fact.  In practise this means that the Triple does not contain any Blank Nodes/Variables
            </para>
            </remarks>
        </member>
        <member name="T:VDS.RDF.Graphs.BaseTripleComparer">
            <summary>
            Abstract base class for Triple Comparers which provide for comparisons using different node comparers
            </summary>
        </member>
        <member name="F:VDS.RDF.Graphs.BaseTripleComparer._nodeComparer">
            <summary>
            Node Comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseTripleComparer.#ctor">
            <summary>
            Creates a new Triple Comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseTripleComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Triple Comparer
            </summary>
            <param name="nodeComparer">Node Comparer to use</param>
        </member>
        <member name="M:VDS.RDF.Graphs.BaseTripleComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.FullTripleComparer">
            <summary>
            Triple comparer which compares on subjects, then predicates and finally objects
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.FullTripleComparer.#ctor">
            <summary>
            Creates a new Full Triple comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.FullTripleComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Full Triple comparer that uses a specific Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.Graphs.FullTripleComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.SubjectComparer">
            <summary>
            Triple comparer which compares only on subjects
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectComparer.#ctor">
            <summary>
            Creates a new Subject comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Subject comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.PredicateComparer">
            <summary>
            Triple comparer which compares only on predicates
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.PredicateComparer.#ctor">
            <summary>
            Creates a new Predicate comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.PredicateComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Predicate comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node Comparer</param>
        </member>
        <member name="M:VDS.RDF.Graphs.PredicateComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.ObjectComparer">
            <summary>
            Triple comparer which compares only on objects
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ObjectComparer.#ctor">
            <summary>
            Creates a new Object comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ObjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Object comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.Graphs.ObjectComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.SubjectPredicateComparer">
            <summary>
            Triple comparer which compares on subjects and then predicates
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectPredicateComparer.#ctor">
            <summary>
            Creates a new Subject Predicate comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectPredicateComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Subject Predicate comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node Comparer</param>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectPredicateComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.SubjectObjectComparer">
            <summary>
            Triple comparer which compares on subjects and then objects
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectObjectComparer.#ctor">
            <summary>
            Creates a new Subject Object comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectObjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Subject Object comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.Graphs.SubjectObjectComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.PredicateObjectComparer">
            <summary>
            Triple comparer which compares on predicates and then objects
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.PredicateObjectComparer.#ctor">
            <summary>
            Creates a new Predicate Object comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.PredicateObjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Predicate Object comparer using the provided Node comparer
            </summary>
            <param name="nodeComparer">Node comparer</param>
        </member>
        <member name="M:VDS.RDF.Graphs.PredicateObjectComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Graphs.ObjectSubjectComparer">
            <summary>
            Triple comparer which compares on objects and then subjects
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ObjectSubjectComparer.#ctor">
            <summary>
            Creates a new Object Subject comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ObjectSubjectComparer.#ctor(System.Collections.Generic.IComparer{VDS.RDF.Nodes.INode})">
            <summary>
            Creates a new Object Subject comparer using the provided Node comparer
            </summary>
        </member>
        <member name="M:VDS.RDF.Graphs.ObjectSubjectComparer.Compare(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.Triple)">
            <summary>
            Compares two Triples
            </summary>
            <param name="x">Triple</param>
            <param name="y">Triple</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Nodes.NonNormalizedLiteralNode">
            <summary>
            Class for representing Literal Nodes where the Literal values are not normalized
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.NonNormalizedLiteralNode.#ctor(System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="literal">String value of the Literal</param>
        </member>
        <member name="M:VDS.RDF.Nodes.NonNormalizedLiteralNode.#ctor(System.String,System.String)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="literal">String value of the Literal</param>
            <param name="langspec">Lanaguage Specifier for the Literal</param>
        </member>
        <member name="M:VDS.RDF.Nodes.NonNormalizedLiteralNode.#ctor(System.String,System.Uri)">
            <summary>
            Internal Only Constructor for Literal Nodes
            </summary>
            <param name="literal">String value of the Literal</param>
            <param name="datatype">Uri for the Literals Data Type</param>
        </member>
        <member name="M:VDS.RDF.Nodes.NonNormalizedLiteralNode.#ctor">
            <summary>
            Deserialization Only Constructor
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.NonNormalizedLiteralNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization Constructor
            </summary>
            <param name="info">Serialization Information</param>
            <param name="context">Streaming Context</param>
        </member>
        <member name="M:VDS.RDF.Nodes.NonNormalizedLiteralNode.CompareTo(VDS.RDF.Nodes.NonNormalizedLiteralNode)">
            <summary>
            Implementation of Compare To for Literal Nodes
            </summary>
            <param name="other">Literal Node to Compare To</param>
            <returns></returns>
            <remarks>
            Simply invokes the more general implementation of this method
            </remarks>
        </member>
        <member name="T:VDS.RDF.Namespaces.INamespaceMapper">
            <summary>
            Interface for Namespace Maps which provide mappings between Namespace Prefixes and Namespace URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.INamespaceMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace to the Namespace Map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
            <remarks>Namespace prefix cannot be empty and namespace URI must be absolute</remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.INamespaceMapper.Clear">
            <summary>
            Clears the Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.INamespaceMapper.GetNamespaceUri(System.String)">
            <summary>
            Returns the Namespace URI associated with the given Prefix
            </summary>
            <param name="prefix">The Prefix to lookup the Namespace URI for</param>
            <returns>URI for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.INamespaceMapper.GetPrefix(System.Uri)">
            <summary>
            Returns the Prefix associated with the given Namespace URI
            </summary>
            <param name="uri">The Namespace URI to lookup the Prefix for</param>
            <returns>String prefix for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.INamespaceMapper.HasNamespace(System.String)">
            <summary>
            Method which checks whether a given Namespace Prefix is defined
            </summary>
            <param name="prefix">Prefix to test</param>
            <returns>True if the namespace is defined in this map</returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.INamespaceMapper.Import(VDS.RDF.Namespaces.INamespaceMapper)">
            <summary>
            Imports the contents of another Namespace Map into this Namespace Map
            </summary>
            <param name="nsmap">Namespace Map to import</param>
            <remarks>
            Prefixes in the imported Map which are already defined in this Map are ignored, this may change in future releases.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.INamespaceMapper.ReduceToPrefixedName(System.String,System.String@)">
            <summary>
            A Function which attempts to reduce a URI to a prefixed name
            </summary>
            <param name="uri">The URI to attempt to reduce</param>
            <param name="prefixedName">The value to output the prefixed name to if possible</param>
            <returns></returns>
            <remarks>
            This function will return a Boolean indicated whether it succeeded in reducing the URI to a prefixed name.  If it did then the out parameter prefixedName will contain the reduction, otherwise it will be the empty string.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.INamespaceMapper.RemoveNamespace(System.String)">
            <summary>
            Removes a Namespace from the Namespace Map
            </summary>
            <param name="prefix">Namespace Prefix of the Namespace to remove</param>
        </member>
        <member name="P:VDS.RDF.Namespaces.INamespaceMapper.IsEmpty">
            <summary>
            Gets whether the map is empty
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.INamespaceMapper.NamespaceAdded">
            <summary>
            Event which is raised when a Namespace is Added
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.INamespaceMapper.NamespaceModified">
            <summary>
            Event which is raised when a Namespace is Modified
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.INamespaceMapper.NamespaceRemoved">
            <summary>
            Event which is raised when a Namespace is Removed
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.INamespaceMapper.Prefixes">
            <summary>
            Gets a Enumeratorion of all the Prefixes
            </summary>
        </member>
        <member name="T:VDS.RDF.Namespaces.NamespaceChanged">
            <summary>
            Delegate Type for the Events of the Namespace Mapper
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="T:VDS.RDF.Namespaces.NamespaceMapper">
            <summary>
            Class for representing Mappings between Prefixes and Namespace URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.Namespaces.NamespaceMapper.RDF">
            <summary>
            Constant Uri for the RDF Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Namespaces.NamespaceMapper.RDFS">
            <summary>
            Constant Uri for the RDF Scheme Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Namespaces.NamespaceMapper.XMLSCHEMA">
            <summary>
            Constant Uri for the XML Scheme Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Namespaces.NamespaceMapper.OWL">
            <summary>
            Constant Uri for the OWL Namespace
            </summary>
        </member>
        <member name="F:VDS.RDF.Namespaces.NamespaceMapper._uris">
            <summary>
            Mapping of Prefixes to URIs
            </summary>
        </member>
        <member name="F:VDS.RDF.Namespaces.NamespaceMapper._prefixes">
            <summary>
            Mapping of URIs to Prefixes
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.#ctor">
            <summary>
            Constructs a new Namespace Map
            </summary>
            <remarks>The Prefixes rdf, rdfs and xsd are automatically defined</remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.#ctor(System.Boolean)">
            <summary>
            Constructs a new Namespace Map which is optionally empty
            </summary>
            <param name="empty">Whether the Namespace Map should be empty, if set to false the Prefixes rdf, rdfs and xsd are automatically defined</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.#ctor(VDS.RDF.Namespaces.INamespaceMapper)">
            <summary>
            Constructs a new Namespace Map which is based on an existing map
            </summary>
            <param name="nsmapper"></param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.GetPrefix(System.Uri)">
            <summary>
            Returns the Prefix associated with the given Namespace URI
            </summary>
            <param name="uri">The Namespace URI to lookup the Prefix for</param>
            <returns>String prefix for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.GetNamespaceUri(System.String)">
            <summary>
            Returns the Namespace URI associated with the given Prefix
            </summary>
            <param name="prefix">The Prefix to lookup the Namespace URI for</param>
            <returns>URI for the Namespace</returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace to the Namespace Map
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.RemoveNamespace(System.String)">
            <summary>
            Removes a Namespace from the NamespaceMapper
            </summary>
            <param name="prefix">Namespace Prefix of the Namespace to remove</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.HasNamespace(System.String)">
            <summary>
            Method which checks whether a given Namespace Prefix is defined
            </summary>
            <param name="prefix">Prefix to test</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.Clear">
            <summary>
            Clears the Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.ReduceToPrefixedName(System.String,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="prefixedName">The value to output the QName to if possible</param>
            <returns></returns>
            <remarks>This function will return a Boolean indicated whether it succeeded in reducing the Uri to a QName.  If it did then the out parameter prefixedName will contain the reduction, otherwise it will be the empty string.</remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.Import(VDS.RDF.Namespaces.INamespaceMapper)">
            <summary>
            Imports the contents of another Namespace Map into this Namespace Map
            </summary>
            <param name="nsmap">Namespace Map to import</param>
            <remarks>
            Prefixes in the imported Map which are already defined in this Map are ignored, this may change in future releases.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.OnNamespaceAdded(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceAdded Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.OnNamespaceModified(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceModified Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.OnNamespaceRemoved(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceRemoved Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NamespaceMapper.Dispose">
            <summary>
            Disposes of a Namespace Map
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.NamespaceMapper.IsEmpty">
            <summary>
            Gets whether the map is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.NamespaceMapper.Prefixes">
            <summary>
            Gets a Enumerator of all the Prefixes
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.NamespaceMapper.NamespaceAdded">
            <summary>
            Event which is raised when a Namespace is Added
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.NamespaceMapper.NamespaceModified">
            <summary>
            Event which is raised when a Namespace is Modified
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.NamespaceMapper.NamespaceRemoved">
            <summary>
            Event which is raised when a Namespace is Removed
            </summary>
        </member>
        <member name="T:VDS.RDF.Namespaces.QNameOutputMapper">
            <summary>
            Class for representing Mappings from URIs to QNames
            </summary>
            <remarks>
            Used primarily in outputting RDF syntax
            </remarks>
        </member>
        <member name="F:VDS.RDF.Namespaces.QNameOutputMapper._mapping">
            <summary>
            Mapping of URIs to QNames
            </summary>
        </member>
        <member name="F:VDS.RDF.Namespaces.QNameOutputMapper._nextNamespaceID">
            <summary>
            Next available Temporary Namespace ID
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameOutputMapper.#ctor(VDS.RDF.Namespaces.INamespaceMapper)">
            <summary>
            Creates a new QName Output Mapper using the given Namespace Map
            </summary>
            <param name="nsmapper">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameOutputMapper.#ctor">
            <summary>
            Creates a new QName Output Mapper which has an empty Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameOutputMapper.ReduceToPrefixedName(System.String,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="prefixedName">The value to output the QName to if possible</param>
            <returns></returns>
            <remarks>This function will return a Boolean indicated whether it succeeded in reducing the Uri to a QName.  If it did then the out parameter prefixedName will contain the reduction, otherwise it will be the empty string.</remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameOutputMapper.ReduceToPrefixedName(System.String,System.String@,System.String@)">
            <summary>
            A Function which attempts to reduce a Uri to a QName and issues a Temporary Namespace if required
            </summary>
            <param name="uri">The Uri to attempt to reduce</param>
            <param name="qname">The value to output the QName to if possible</param>
            <param name="tempNamespace">The Temporary Namespace issued (if any)</param>
            <returns></returns>
            <remarks>
            <para>
            This function will always returns a possible QName for the URI if the format of the URI permits it.  It doesn't guarentee that the QName will be valid for the syntax it is being written to - it is up to implementers of writers to validate the QNames returned.
            </para>
            <para>
            Where necessary a Temporary Namespace will be issued and the <paramref name="tempNamespace">tempNamespace</paramref> parameter will be set to the prefix of the new temporary namespace
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameOutputMapper.AddToCache(System.String,VDS.RDF.Namespaces.QNameMapping)">
            <summary>
            Adds a QName mapping to the cache
            </summary>
            <param name="uri">URI</param>
            <param name="mapping">Mapping</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameOutputMapper.GetNextTemporaryNamespacePrefix">
            <summary>
            Gets the next available Temporary Namespace ID
            </summary>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Namespaces.ThreadSafeQNameOutputMapper">
            <summary>
            Thread Safe version of the <see cref="T:VDS.RDF.Namespaces.QNameOutputMapper">QNameOutputMapper</see>
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.ThreadSafeQNameOutputMapper.#ctor(VDS.RDF.Namespaces.INamespaceMapper)">
            <summary>
            Creates a new Thread Safe QName Output Mapper
            </summary>
            <param name="nsmapper">Namespace Mapper</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.ThreadSafeQNameOutputMapper.AddToCache(System.String,VDS.RDF.Namespaces.QNameMapping)">
            <summary>
            Adds a QName Mapping to the Cache in a Thread Safe way
            </summary>
            <param name="key">Key</param>
            <param name="value">Value</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.ThreadSafeQNameOutputMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace to the QName Output Mapper
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
        </member>
        <member name="T:VDS.RDF.Namespaces.QNameMapping">
            <summary>
            Represents a mapping from a URI to a QName
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameMapping.#ctor(System.String)">
            <summary>
            Creates a new QName Mapping
            </summary>
            <param name="u">URI</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameMapping.ToString">
            <summary>
            Gets the String representation of the URI
            </summary>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.QNameMapping.Equals(System.Object)">
            <summary>
            Checks whether this is equal to another Object
            </summary>
            <param name="obj">Object to test against</param>
            <returns></returns>
        </member>
        <member name="P:VDS.RDF.Namespaces.QNameMapping.Uri">
            <summary>
            URI this is a mapping for
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.QNameMapping.QName">
            <summary>
            QName this URI maps to
            </summary>
        </member>
        <member name="T:VDS.RDF.Namespaces.NestedNamespaceMapper">
            <summary>
            A Namespace Mapper which has an explicit notion of Nesting
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.#ctor">
            <summary>
            Constructs a new Namespace Map
            </summary>
            <remarks>The Prefixes rdf, rdfs and xsd are automatically defined</remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.#ctor(System.Boolean)">
            <summary>
            Constructs a new Namespace Map which is optionally empty
            </summary>
            <param name="empty">Whether the Namespace Map should be empty, if set to false the Prefixes rdf, rdfs and xsd are automatically defined</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.AddNamespace(System.String,System.Uri)">
            <summary>
            Adds a Namespace at the Current Nesting Level
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.Clear">
            <summary>
            Clears the Namespace Map
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.GetNamespaceUri(System.String)">
            <summary>
            Gets the Namespace URI for the given Prefix at the current Nesting Level
            </summary>
            <param name="prefix">Prefix</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.GetPrefix(System.Uri)">
            <summary>
            Gets the Namespace Prefix for the given URI at the current Nesting Level
            </summary>
            <param name="uri">Namespace URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.GetNestingLevel(System.String)">
            <summary>
            Gets the Nesting Level at which the given Namespace is definition is defined
            </summary>
            <param name="prefix">Prefix</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.HasNamespace(System.String)">
            <summary>
            Gets whether the given Namespace exists
            </summary>
            <param name="prefix">Prefix</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.Import(VDS.RDF.Namespaces.INamespaceMapper)">
            <summary>
            Imports another Namespace Map into this one
            </summary>
            <param name="nsmap">Namespace Map</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.IncrementNesting">
            <summary>
            Increments the Nesting Level
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.DecrementNesting">
            <summary>
            Decrements the Nesting Level
            </summary>
            <remarks>
            When the Nesting Level is decremented any Namespaces defined at a greater Nesting Level are now out of scope and so are removed from the Mapper
            </remarks>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.RaiseNamespaceAdded(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceAdded Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.RaiseNamespaceModified(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceModified Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.OnNamespaceRemoved(System.String,System.Uri)">
            <summary>
            Internal Helper for the NamespaceRemoved Event which raises it only when a Handler is registered
            </summary>
            <param name="prefix">Namespace Prefix</param>
            <param name="uri">Namespace Uri</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.ReduceToPrefixedName(System.String,System.String@)">
            <summary>
            Tries to reduce a URI to a QName using this Namespace Map
            </summary>
            <param name="uri">URI</param>
            <param name="prefixedName">Resulting QName</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.RemoveNamespace(System.String)">
            <summary>
            Removes a Namespace provided that Namespace is defined on the current Nesting Level
            </summary>
            <param name="prefix">Prefix</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedNamespaceMapper.Dispose">
            <summary>
            Disposes of the Namespace Map
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.NestedNamespaceMapper.IsEmpty">
            <summary>
            Gets whether the map is empty
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.NestedNamespaceMapper.NestingLevel">
            <summary>
            Gets the current Nesting Level
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.NestedNamespaceMapper.NamespaceAdded">
            <summary>
            Event which occurs when a Namespace is added
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.NestedNamespaceMapper.NamespaceModified">
            <summary>
            Event which occurs when a Namespace is modified
            </summary>
        </member>
        <member name="E:VDS.RDF.Namespaces.NestedNamespaceMapper.NamespaceRemoved">
            <summary>
            Event which occurs when a Namespace is removed
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.NestedNamespaceMapper.Prefixes">
            <summary>
            Gets the Namespace Prefixes
            </summary>
        </member>
        <member name="T:VDS.RDF.Namespaces.NestedMapping">
            <summary>
            Class used to hold Nested Namespace definition information
            </summary>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedMapping.#ctor(System.String,System.Uri,System.Int32)">
            <summary>
            Creates a new Nested Mapping
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
            <param name="level">Nesting Level</param>
        </member>
        <member name="M:VDS.RDF.Namespaces.NestedMapping.#ctor(System.String,System.Uri)">
            <summary>
            Creates a new Nested Mapping
            </summary>
            <param name="prefix">Prefix</param>
            <param name="uri">Namespace URI</param>
        </member>
        <member name="P:VDS.RDF.Namespaces.NestedMapping.Level">
            <summary>
            Gets the Nesting Level
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.NestedMapping.Prefix">
            <summary>
            Gets the Namespace Prefix
            </summary>
        </member>
        <member name="P:VDS.RDF.Namespaces.NestedMapping.Uri">
            <summary>
            Gets the Namespace URI
            </summary>
        </member>
        <member name="T:VDS.RDF.Nodes.EqualityHelper">
            <summary>
            Static Helper class containing standard implementations of Equality between various Node types
            </summary>
        </member>
        <member name="M:VDS.RDF.Nodes.EqualityHelper.AreUrisEqual(System.Uri,System.Uri)">
            <summary>
            Determines whether two URIs are equal
            </summary>
            <param name="a">First URI</param>
            <param name="b">Second URI</param>
            <returns></returns>
            <remarks>
            Unlike the Equals method provided by the <see cref="T:System.Uri">Uri</see> class by default this takes into account Fragment IDs which are essential for checking URI equality in RDF
            </remarks>
        </member>
        <member name="M:VDS.RDF.Nodes.EqualityHelper.AreNodesEqual(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether two nodes are equal
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.EqualityHelper.AreUrisEqual(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether two URI nodes are equal
            </summary>
            <param name="a">First URI Node</param>
            <param name="b">Second URI Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.EqualityHelper.AreLiteralsEqual(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether two Literals are equal
            </summary>
            <param name="a">First Literal</param>
            <param name="b">Second Literal</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.EqualityHelper.AreBlankNodesEqual(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether two Blank Nodes are equal
            </summary>
            <param name="a">First Blank Node</param>
            <param name="b">Second Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.EqualityHelper.AreGraphLiteralsEqual(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether two Graph Literals are equal
            </summary>
            <param name="a">First Blank Node</param>
            <param name="b">Second Blank Node</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Nodes.EqualityHelper.AreVariablesEqual(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode)">
            <summary>
            Determines whether two Variable Nodes are equal
            </summary>
            <param name="a">First Variable Node</param>
            <param name="b">Second Variable Node</param>
            <returns></returns>
        </member>
        <member name="T:VDS.RDF.Extensions">
            <summary>
            Provides useful Extension Methods for use elsewhere in the Library
            </summary>
        </member>
        <member name="M:VDS.RDF.Extensions.AsEnumerable``1(``0)">
            <summary>
            Takes a single item and generates an IEnumerable containing only it
            </summary>
            <typeparam name="T">Type of the enumerable</typeparam>
            <param name="item">Item to wrap in an IEnumerable</param>
            <returns></returns>
            <remarks>
            This method taken from Stack Overflow - see <a href="http://stackoverflow.com/questions/1577822/passing-a-single-item-as-ienumerablet">here</a>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.AsQuads(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple},VDS.RDF.Nodes.INode)">
            <summary>
            Converts an enumerable of triples into an enumerable of quads with the given graph name
            </summary>
            <param name="ts">Triples</param>
            <param name="graphName">Graph name</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.IsDisjoint``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the contents of two enumerables are disjoint
            </summary>
            <typeparam name="T">Type Parameter</typeparam>
            <param name="x">An Enumerable</param>
            <param name="y">Another Enumerable</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithSubject(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple},VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Subject
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="subject">Subject to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithPredicate(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple},VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Predicate
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="predicate">Predicate to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.WithObject(System.Collections.Generic.IEnumerable{VDS.RDF.Graphs.Triple},VDS.RDF.Nodes.INode)">
            <summary>
            Gets the Subset of Triples from an existing Enumerable that have a given Object
            </summary>
            <param name="ts">Enumerable of Triples</param>
            <param name="obj">Object to match</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.BlankNodes(System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Gets the Blank Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GraphLiteralNodes(System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Gets the Graph Literal Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.LiteralNodes(System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Gets the Literal Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.UriNodes(System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Gets the URI Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.VariableNodes(System.Collections.Generic.IEnumerable{VDS.RDF.Nodes.INode})">
            <summary>
            Gets the Variable Nodes
            </summary>
            <param name="ns">Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GetEnhancedHashCode(System.Uri)">
            <summary>
            Gets an Enhanced Hash Code for a Uri
            </summary>
            <param name="u">Uri to get Hash Code for</param>
            <returns></returns>
            <remarks>
            The .Net <see cref="T:System.Uri">Uri</see> class Hash Code ignores the Fragment ID when computing the Hash Code which means that URIs with the same basic URI but different Fragment IDs have identical Hash Codes.  This is perfectly acceptable and sensible behaviour for normal URI usage since Fragment IDs are only relevant to the Client and not the Server.  <strong>But</strong> in the case of URIs in RDF the Fragment ID is significant and so we need in some circumstances to compute a Hash Code which includes this information.  However in the case on relative URIs we just use the normal hash code of the URI.
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.GetSha256Hash(System.Uri)">
            <summary>
            Gets an SHA256 Hash for a URI
            </summary>
            <param name="u">URI to get Hash Code for</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.GetSha256Hash(System.String)">
            <summary>
            Gets a SHA256 Hash for a String
            </summary>
            <param name="s">String to hash</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyNode(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Copies a Node to the target Graph
            </summary>
            <param name="n">Node to copy</param>
            <param name="target">Target Graph</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyNode(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">Tools.CopyNode()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyNode(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph,System.Boolean)">
            <summary>
            Copies a Node to the target Graph
            </summary>
            <param name="n">Node to copy</param>
            <param name="target">Target Graph</param>
            <param name="keepOriginalGraphUri">Indicates whether Nodes should preserve the Graph Uri of the Graph they originated from</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyNode(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph,System.Boolean)">Tools.CopyNode()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyTriple(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.IGraph)">
            <summary>
            Copies a Triple to the target Graph
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Target Graph</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.IGraph)">Tools.CopyTriple()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.CopyTriple(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.IGraph,System.Boolean)">
            <summary>
            Copies a Triple to the target Graph
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Target Graph</param>
            <param name="keepOriginalGraphUri">Indicates whether Nodes should preserve the Graph Uri of the Graph they originated from</param>
            <returns></returns>
            <remarks>Shorthand for the <see cref="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.IGraph,System.Boolean)">Tools.CopyTriple()</see> method</remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.MapTriple(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.IGraph,System.Collections.Generic.Dictionary{VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INode})">
            <summary>
            Copies a Triple from one Graph mapping Nodes as appropriate
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">TargetGraph</param>
            <param name="mapping">Mapping of Nodes</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToSafeString(System.Object)">
            <summary>
            Gets either the String representation of the Object or the Empty String if the object is null
            </summary>
            <param name="obj">Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToSafeString(System.Uri)">
            <summary>
            Gets either the String representation of the URI or the Empty String if the URI is null
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToSafeUri(System.String)">
            <summary>
            Turns a string into a safe URI
            </summary>
            <param name="str">String</param>
            <returns>Either null if the string is null/empty or a URI otherwise</returns>
        </member>
        <member name="M:VDS.RDF.Extensions.ToString(System.Uri,VDS.RDF.Writing.Formatting.IUriFormatter)">
            <summary>
            Gets the String representation of the URI formatted using the given Formatter
            </summary>
            <param name="u">URI</param>
            <param name="formatter">URI Formatter</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.AppendIndented(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Appends a String to the StringBuilder with an indent of <paramref name="indent"/> spaces
            </summary>
            <param name="builder">String Builder</param>
            <param name="line">String to append</param>
            <param name="indent">Indent</param>
        </member>
        <member name="M:VDS.RDF.Extensions.AppendLineIndented(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Appends a String to the StringBuilder with an indent of <paramref name="indent"/> spaces
            </summary>
            <param name="builder">String Builder</param>
            <param name="line">String to append</param>
            <param name="indent">Indent</param>
            <remarks>
            Strings containing new lines are split over multiple lines
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.EscapeBackslashes(System.String,System.Char[])">
            <summary>
            Takes a String and escapes any backslashes in it which are not followed by a valid escape character
            </summary>
            <param name="value">String value</param>
            <param name="cs">Valid Escape Characters i.e. characters which may follow a backslash</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.IsAscii(System.String)">
            <summary>
            Determines whether a string is ASCII
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.IsFullyEscaped(System.String,System.Char[],System.Char[])">
            <summary>
            Determines whether a String is fully escaped
            </summary>
            <param name="value">String value</param>
            <param name="cs">Valid Escape Characters i.e. characters which may follow a backslash</param>
            <param name="ds">Characters which must be escaped i.e. must be preceded by a backslash</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Extensions.Escape(System.String,System.Char)">
            <summary>
            Escapes all occurrences of a given character in a String
            </summary>
            <param name="value">String</param>
            <param name="toEscape">Character to escape</param>
            <returns></returns>
            <remarks>
            Ignores all existing escapes (indicated by a \) and so avoids double escaping as far as possible
            </remarks>
        </member>
        <member name="M:VDS.RDF.Extensions.Escape(System.String,System.Char,System.Char)">
            <summary>
            Escapes all occurrences of a given character in a String using the given escape character
            </summary>
            <param name="value">String</param>
            <param name="toEscape">Character to escape</param>
            <param name="escapeAs">Character to escape as</param>
            <returns></returns>
            <remarks>
            Ignores all existing escapes (indicated by a \) and so avoids double escaping as far as possible
            </remarks>
        </member>
        <member name="T:VDS.RDF.LiteralEqualityMode">
            <summary>
            Possible Literal Equality Mode Settings
            </summary>
        </member>
        <member name="F:VDS.RDF.LiteralEqualityMode.Strict">
            <summary>
            Strict Mode compares Literals according to the official W3C RDF Specification
            </summary>
            <remarks>
            This means Literals are equal if and only if:
            <ol>
            <li>The Lexical Values are identical when compared using Ordinal Comparison</li>
            <li>The Language Tags if present are identical</li>
            <li>The Datatypes if present are identical</li>
            </ol>
            </remarks>
        </member>
        <member name="F:VDS.RDF.LiteralEqualityMode.Loose">
            <summary>
            Loose Mode compares Literals based on values (if they have known Datatypes)
            </summary>
            <remarks>
            This means Literals can be equal if they have lexically different values which are equivalent when converted to the Datatype.
            <br/><br/>
            Literals without Datatypes and those whose Datatypes are unknown or not handled by the Library will be compared using lexical equivalence as with <see cref="F:VDS.RDF.LiteralEqualityMode.Strict">Strict</see> mode.
            </remarks>
        </member>
        <member name="T:VDS.RDF.Options">
            <summary>
            Configures Global Static Options for the Library
            </summary>
            <remarks>
            Some of these are Debug Build only, please see the Remarks on individual members for more detail
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.Rdf11">
            <summary>
            Gets/Sets whether RDF 1.1 mode is enabled (defaults to enabled)
            </summary>
            <remarks>
            <para>
            RDF 1.1 is the family of updated RDF specifications formally published as W3C recommendations in/around late 2013.  They may some changes to the semantics of RDF which have user noticeable effects, the most visible of these is that all literals are now implicitly typed i.e. there are no untyped literals in RDF 1.1
            </para>
            <para>
            With RDF 1.1 mode enabled there are a number of behavioural differences:
            </para>
            <ul>
            <li>All literals are implicitly typed, literals with no type/language specifier are typed as <code>xsd:string</code> while those with language specifiers are typed as <code>rdf:langString</code></li>
            
            </ul>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.LiteralEqualityMode">
            <summary>
            Gets/Sets the Mode used to compute Literal Equality (Default is <see cref="F:VDS.RDF.LiteralEqualityMode.Strict">Strict</see> which enforces the W3C RDF Specification)
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.LiteralValueNormalization">
            <summary>
            Gets/Sets whether Literal Values should be normalized (defaults to disabled)
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.FullTripleIndexing">
            <summary>
            Controls whether the indexed triple collections will create full indexes for the Triples inserted into it (defaults to enabled)
            </summary>
            <remarks>
            <para>
            An indexed triple collections typically creates indexes at least based upon Subjects, Predicates and Objects.  When full indexing is enabled it may also create indexes based on Subject-Predicate, Predicate-Object and Subject-Object pairs which may improve query speed but will use additional memory.  Actual implementations may create more/less indexes depending on their underlying data structures but they should respect this setting when deciding how many indexes to create.
            </para>
            <para>
            Default setting for Full Indexing is enabled, enabling/disabling it only has an effect on indexed triple collection instances instantiated after full indexing was enabled/disabled i.e. existing Graphs in memory using the indexed triple collections continue to use the full indexing setting that was present when they were instantiated.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.ValidateIris">
            <summary>
            Gets/Sets whether IRIs are validated by parsers which support this functionality (defaults to disabled)
            </summary>
            <remarks>
            When enabled certain parsers will validate all IRIs they see to ensure that they are valid and throw a parser error if they are not.  Since there is a performance penalty associated with this and many older RDF standards were written pre-IRIs (thus enforcing IRI validity would reject data considered valid by those specifications) this feature is disabled by default.
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.ForceHttpBasicAuth">
            <summary>
            Gets/Sets whether Basic HTTP authentication should be forced (defaults to disabled)
            </summary>
            <remarks>
            <para>
            There have been reported problems where some servers don't cope nicely with the HTTP authentication challenge response procedure resulting in failed HTTP requests.  If the server only uses Basic HTTP authentication then you can opt to force dotNetRDF to always include the HTTP basic authentication header in requests and thus workaround this problem.
            </para>
            <para>
            <strong>Warning:</strong> Under Silverlight this will only work correctly if usernames and passwords are composed only of characters within the ASCII range.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.InternUris">
            <summary>
            Gets/Sets whether the library will attempt to intern URIs to reduce memory usage (defaults to enabled)
            </summary>
            <remarks>
            <para>
            Interning URIs trades off memory usage for performance, by interning URIs so the same URI strings are represented by the same <see cref="T:System.Uri"/> instances we make a lot of equality checks reference equality checks which can substantially boost performance of some operations.
            </para>
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.HttpDebugging">
            <summary>
            Gets/Sets whether HTTP Request and Response Information should be output to the Console Standard Out for Debugging purposes (defaults to disabled)
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.HttpFullDebugging">
            <summary>
            Gets/Sets whether the HTTP Response Stream should be output to the Console Standard Output for Debugging purposes (defaults to disabled)
            </summary>
        </member>
        <member name="P:VDS.RDF.Options.DefaultCulture">
            <summary>
            Gets/Sets the default culture literal comparison when literals are string or not implicitely comparable (different types, parse/cast error...)
            </summary>
            <remarks>
            The default is set to the invariant culture to preserve behavioural backwards compatibility with past versions of dotNetRDF
            </remarks>
        </member>
        <member name="P:VDS.RDF.Options.DefaultComparisonOptions">
            <summary>
            Gets/Sets the default collation for literal comparison when literals are string or not implicitely comparable (different types, parse/cast error...)
            </summary>
            <remarks>
            The default is set to <see cref="F:System.Globalization.CompareOptions.Ordinal"/> to preserve behavioural backwards compatibility with past versions of dotNetRDF
            </remarks>
        </member>
        <member name="T:VDS.RDF.Tools">
            <summary>
            Tools class which contains a number of utility methods which are declared as static methods
            </summary>
        </member>
        <member name="F:VDS.RDF.Tools.PlainLiteralHashCodeSalt">
            <summary>
            Constants used to add salt to the hashes of different Literal Nodes
            </summary>
        </member>
        <member name="M:VDS.RDF.Tools.IsValidBaseUri(System.Uri)">
            <summary>
            Checks whether a Uri is valid as a Base Uri for resolving Relative URIs against
            </summary>
            <param name="baseUri">Base Uri to test</param>
            <returns>True if the Base Uri can be used to resolve Relative URIs against</returns>
            <remarks>A Base Uri is valid if it is an absolute Uri and not using the mailto: scheme</remarks>
        </member>
        <member name="M:VDS.RDF.Tools.FixMalformedUriStrings(System.String)">
            <summary>
            Checks whether a URI Reference appears malformed and if so fixes it
            </summary>
            <param name="uriref">URI Reference</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.StripUriFragment(System.Uri)">
            <summary>
            Returns a URI with any Fragment ID removed from it
            </summary>
            <param name="u">URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveUri(System.String,System.String)">
            <summary>
            Generic Helper Function which Resolves Uri References against a Base Uri
            </summary>
            <param name="uriref">Uri Reference to resolve</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns>Resolved Uri as a String</returns>
            <exception cref="T:System.UriFormatException">Uri Format Exception if one/both of the URIs is malformed</exception>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveUri(System.Uri,System.Uri)">
            <summary>
            Generic Helper Function which Resolves Uri References against a Base Uri
            </summary>
            <param name="uriref">Uri Reference to resolve</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns>Resolved Uri as a String</returns>
            <exception cref="T:System.UriFormatException">Uri Format Exception if one/both of the URIs is malformed</exception>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveQName(System.String,VDS.RDF.Namespaces.INamespaceMapper,System.Uri)">
            <summary>
            Resolves a QName into a Uri using the Namespace Mapper and Base Uri provided
            </summary>
            <param name="qname">QName to resolve</param>
            <param name="nsmap">Namespace Map to resolve against</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.ResolveQName(System.String,VDS.RDF.Namespaces.INamespaceMapper,System.Uri,System.Boolean)">
            <summary>
            Resolves a QName into a Uri using the Namespace Mapper and Base Uri provided
            </summary>
            <param name="qname">QName to resolve</param>
            <param name="nsmap">Namespace Map to resolve against</param>
            <param name="baseUri">Base Uri to resolve against</param>
            <param name="allowDefaultPrefixFallback">Whether when the default prefix is used but not defined it can fallback to Base URI</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyNode(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph,System.Boolean)">
            <summary>
            Copies a Node so it can be used in another Graph since by default Triples cannot contain Nodes from more than one Graph
            </summary>
            <param name="original">Node to Copy</param>
            <param name="target">Graph to Copy into</param>
            <param name="keepOriginalGraphUri">Indicates whether the Copy should preserve the Graph Uri of the Node being copied</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyNode(VDS.RDF.Nodes.INode,VDS.RDF.Graphs.IGraph)">
            <summary>
            Copies a Node so it can be used in another Graph since by default Triples cannot contain Nodes from more than one Graph
            </summary>
            <param name="original">Node to Copy</param>
            <param name="target">Graph to Copy into</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Warning:</strong> Copying Blank Nodes may lead to unforseen circumstances since no remapping of IDs between Graphs is done
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Tools.CopyNode(VDS.RDF.Nodes.INode,VDS.RDF.Nodes.INodeFactory)">
            <summary>
            Copies a Node using another Node Factory
            </summary>
            <param name="original">Node to copy</param>
            <param name="target">Factory to copy into</param>
            <returns></returns>
            <remarks>
            <para>
            <strong>Warning:</strong> Copying Blank Nodes may lead to unforseen circumstances since no remapping of IDs between Factories is done
            </para>
            </remarks>
        </member>
        <member name="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.IGraph)">
            <summary>
            Copies a Triple from one Graph to another
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Graph to copy to</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CopyTriple(VDS.RDF.Graphs.Triple,VDS.RDF.Graphs.IGraph,System.Boolean)">
            <summary>
            Copies a Triple from one Graph to another
            </summary>
            <param name="t">Triple to copy</param>
            <param name="target">Graph to copy to</param>
            <param name="keepOriginalGraphUri">Indicates whether the Copy should preserve the Graph Uri of the Nodes being copied</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CreateHashCode(VDS.RDF.Nodes.INode)">
            <summary>
            Helper method which ensures that nodes return a consistent hash code based on their value
            </summary>
            <param name="n">Node</param>
            <returns>Hash code for the node</returns>
            <remarks>
            This method is provided so that implementors of custom node implementations can ensure that they always return a consistent hash code and thus correctly respect the contract for <em>GetHashCode()</em>
            </remarks>
            <exception cref="T:System.NullReferenceException">Thrown if a null node is passed</exception>
            <exception cref="T:VDS.RDF.Nodes.NodeValueException">Thrown if an unknown node type is passed</exception>
        </member>
        <member name="M:VDS.RDF.Tools.CreateHashCode(VDS.RDF.Graphs.Triple)">
            <summary>
            Helper method which ensures that triples return a consistent hash code based on their value
            </summary>
            <param name="t">Triple</param>
            <returns>Hash code for the triple</returns>
        </member>
        <member name="M:VDS.RDF.Tools.CombineHashCodes(System.Object,System.Object)">
            <summary>
            Does a quick and simple combination of the Hash Codes of two Objects
            </summary>
            <param name="x">First Object</param>
            <param name="y">Second Object</param>
            <returns></returns>
        </member>
        <member name="M:VDS.RDF.Tools.CombineHashCodes(System.Object,System.Uri)">
            <summary>
            Does a quick and simple combination of Hash Codes for an object and a URI
            </summary>
            <param name="x">First Object</param>
            <param name="y">URI</param>
            <returns></returns>
            <remarks>This overload is needed because the .Net hash code implementation for URIs is deficient for use for RDF since it treats URIs with the same fragment as being equivalent (i.e. it excludes the fragment from the hash) whereas in RDF the fragment is significant</remarks>
        </member>
        <member name="M:VDS.RDF.Tools.HttpDebugRequest(System.Net.HttpWebRequest)">
            <summary>
            Prints Debugging Output to the Console Standard Out for a HTTP Web Request
            </summary>
            <param name="httpRequest">HTTP Web Request</param>
            <remarks><strong>Only available in Debug builds</strong></remarks>
        </member>
        <member name="M:VDS.RDF.Tools.HttpDebugResponse(System.Net.HttpWebResponse)">
            <summary>
            Prints Debugging Output to the Console Standard Out for a HTTP Web Response
            </summary>
            <param name="httpResponse">HTTP Web Response</param>
            <remarks><strong>Only available in Debug builds</strong></remarks>
        </member>
        <member name="T:VDS.RDF.UriFactory">
            <summary>
            A static helper class for interning URIs to reduce memory usage
            </summary>
        </member>
        <member name="M:VDS.RDF.UriFactory.UriToSegments(System.Uri)">
            <summary>
            Decomposes a URI into a series of segments for use with the interning
            </summary>
            <param name="u">URI</param>
            <returns>URI segments</returns>
        </member>
        <member name="M:VDS.RDF.UriFactory.Create(System.String)">
            <summary>
            Creates a URI interning it if it is an absolute URI and interning is enabled via the <see cref="P:VDS.RDF.Options.InternUris">Options.InternUris</see> option
            </summary>
            <param name="uri">URI string</param>
            <returns></returns>
            <remarks>
            When URI interning is disabled this is equivalent to just invoking the constructor of the <see cref="T:System.Uri">Uri</see> class with <see cref="F:System.UriKind.RelativeOrAbsolute"/> as the second argument
            </remarks>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the given string is null or invalid</exception>
        </member>
        <member name="M:VDS.RDF.UriFactory.Intern(System.Uri)">
            <summary>
            Interns a URI provided it is an absolute URI and interning has been enabled via the <see cref="P:VDS.RDF.Options.InternUris"/> option
            </summary>
            <param name="u">URI</param>
            <returns>Interned URI</returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the given URI is null</exception>
        </member>
        <member name="M:VDS.RDF.UriFactory.IsInterned(System.Uri)">
            <summary>
            Gets whether a given URI is currently interned
            </summary>
            <param name="u">URI</param>
            <returns>True if the URI is interned, false otherwise</returns>
        </member>
        <member name="M:VDS.RDF.UriFactory.Clear">
            <summary>
            Clears all interned URIs
            </summary>
        </member>
        <member name="M:VDS.RDF.UriFactory.StripUriFragment(System.Uri)">
            <summary>
            Returns a URI with any Fragment ID removed from it
            </summary>
            <param name="u">URI</param>
            <returns>URI with Fragment ID removed</returns>
        </member>
        <member name="M:VDS.RDF.UriFactory.ResolveUri(System.String,System.Uri)">
            <summary>
            Attempts to resolve a possibly relative URI to an absolute URI against a given base
            </summary>
            <param name="uri">Relative or Absolute URI</param>
            <param name="baseUri">Base URI</param>
            <returns>Absolute URI if possible to resolve, relative URI otherwise</returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the string given is null or an invalid URI</exception>
        </member>
        <member name="M:VDS.RDF.UriFactory.ResolveUri(System.Uri,System.Uri)">
            <summary>
            Attempts to resolve a possibly relative URI to an absolute URI against a given base
            </summary>
            <param name="uri">Relative or Absolute URI</param>
            <param name="baseUri">Base URI</param>
            <returns>Absolute URI if possible to resolve, relative URI otherwise</returns>
        </member>
        <member name="M:VDS.RDF.UriFactory.ResolvePrefixedName(System.String,VDS.RDF.Namespaces.INamespaceMapper,System.Uri)">
            <summary>
            Resolves a prefixed name into a URI using the Namespace Mapper and Base URI provided
            </summary>
            <param name="prefixedName">Prefixed name to resolve</param>
            <param name="nsMap">Namespace Map to resolve against</param>
            <param name="baseUri">Base URI to resolve against</param>
            <returns>Resolved prefix name</returns>
        </member>
        <member name="M:VDS.RDF.UriFactory.ResolvePrefixedName(System.String,VDS.RDF.Namespaces.INamespaceMapper,System.Uri,System.Boolean)">
            <summary>
            Resolves a prefixed name into a URI using the Namespace Mapper and Base URI provided
            </summary>
            <param name="prefixedName">Prefixed name to resolve</param>
            <param name="nsmap">Namespace Map to resolve against</param>
            <param name="baseUri">Base URI to resolve against</param>
            <param name="allowDefaultPrefixFallback">Whether when the default prefix is used but not defined it can fallback to Base URI</param>
            <returns>Resolved prefix name</returns>
            <exception cref="T:VDS.RDF.RdfException">Thrown if the prefixed name cannot be resolved for any reason e.g. undefined namespace, results in an invalid URI etc</exception>
        </member>
        <member name="T:VDS.RDF.Configuration.IConfigurationSerializable">
            <summary>
            Interface for Objects which can have their configuration serialized to RDF
            </summary>
        </member>
        <member name="M:VDS.RDF.Configuration.IConfigurationSerializable.SerializeConfiguration(VDS.RDF.Configuration.ConfigurationSerializationContext)">
            <summary>
            Serializes the Configuration in the given context
            </summary>
            <param name="context">Configuration Serialization Context</param>
        </member>
    </members>
</doc>
